<?xml version="1.0" encoding="UTF-8"?>
<ecore:EPackage xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:ecore="http://www.eclipse.org/emf/2002/Ecore" name="CVLMetamodelMaster" nsURI="http:///CVLMetamodelMaster.ecore"
    nsPrefix="CVLMetamodelMaster">
  <eAnnotations source="com.ibm.xtools.common.ui.reduction.editingCapabilities">
    <details key="com.ibm.xtools.activities.umlBBFragment" value="1"/>
    <details key="com.ibm.xtools.activities.umlBBAction" value="1"/>
    <details key="com.ibm.xtools.activities.umlBBClassTemplateParameter" value="1"/>
    <details key="com.ibm.xtools.activities.umlBBPackageTemplateParameter" value="1"/>
    <details key="com.ibm.xtools.activities.umlBBSequence1" value="1"/>
    <details key="com.ibm.xtools.activities.umlBBRelationship1" value="1"/>
    <details key="com.ibm.xtools.activities.umlBBSequence2" value="1"/>
    <details key="com.ibm.xtools.activities.umlBBCollaborationUse" value="1"/>
    <details key="com.ibm.xtools.activities.umlBBRelationship2" value="1"/>
    <details key="com.ibm.xtools.activities.umlBBSubsystem" value="1"/>
    <details key="com.ibm.xtools.activities.umlBBComment1" value="1"/>
    <details key="com.ibm.xtools.activities.umlBBLifeLine" value="1"/>
    <details key="com.ibm.xtools.activities.umlBBComment2" value="1"/>
    <details key="com.ibm.xtools.activities.umlBBActivity1" value="1"/>
    <details key="com.ibm.xtools.activities.umlBBActivity2" value="1"/>
    <details key="com.ibm.xtools.activities.umlBBActivity3" value="1"/>
    <details key="com.ibm.xtools.activities.umlBBFunction" value="1"/>
    <details key="com.ibm.xtools.activities.umlBBActivityDiagram" value="1"/>
    <details key="com.ibm.xtools.activities.umlBBCommunication" value="1"/>
    <details key="com.ibm.xtools.activities.umlBBCollaboration" value="1"/>
    <details key="com.ibm.xtools.activities.umlBBClass" value="1"/>
    <details key="com.ibm.xtools.activities.umlBBInterface" value="1"/>
    <details key="com.ibm.xtools.activities.umlBBUseCaseDiagram" value="1"/>
    <details key="com.ibm.xtools.activities.umlBBTypes1" value="1"/>
    <details key="com.ibm.xtools.activities.umlBBTypes2" value="1"/>
    <details key="com.ibm.xtools.activities.umlBBComponentTemplateParameter" value="1"/>
    <details key="com.ibm.xtools.activities.umlBBTypes3" value="1"/>
    <details key="com.ibm.xtools.activities.umlBBTypes4" value="1"/>
    <details key="com.ibm.xtools.activities.umlBBUseCase1" value="1"/>
    <details key="com.ibm.xtools.activities.umlBBUseCase2" value="1"/>
    <details key="com.ibm.xtools.activities.umlBBPackage" value="1"/>
    <details key="com.ibm.xtools.activities.umlBBComponentDiagram" value="1"/>
    <details key="com.ibm.xtools.activities.umlBBInterfaceTemplateParameter" value="1"/>
    <details key="com.ibm.xtools.activities.umlBBClassDiagram" value="1"/>
    <details key="com.ibm.xtools.activities.umlBBRealization" value="1"/>
    <details key="com.ibm.xtools.activities.umlBBComponent" value="1"/>
    <details key="com.ibm.xtools.activities.umlBBSequenceDiagram" value="1"/>
  </eAnnotations>
  <eSubpackages name="cvl" nsURI="http:///org.omg/CVLMetamodel/cvl" nsPrefix="CVLMetamodel.cvl">
    <eClassifiers xsi:type="ecore:EEnum" name="PrimitiveTypeEnum">
      <eLiterals name="String"/>
      <eLiterals name="Boolean" value="1"/>
      <eLiterals name="Integer" value="2"/>
      <eLiterals name="Real" value="3"/>
      <eLiterals name="UnlimitedNatural" value="4"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="Choice" eSuperTypes="#//cvl/VSpec">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="&lt;p>A choice is a kind of VSpec indicating variability whose resolution requires a binary, yes/no decision. The details of such variability, which could for instance be the fact that some object in the base model is optional or that some substitution may be performed or not, may be specified by binding the choice to a variation point.&lt;/p>&lt;p>####CVLSemanticStart####&lt;/p>&lt;p>&lt;b>&lt;/b>Invariant :&lt;b>&lt;/b> If a choice is implied by parent, it must have a parent.&lt;/p>&lt;p>&lt;b>&lt;/b>OCL :&lt;b>&lt;/b>&lt;/p>&lt;p>-- Choice&lt;/p>&lt;p>-- If a choice is implied by parent, it must have a parent.&lt;/p>&lt;p>context Choice :&lt;/p>&lt;p>inv isImpliedByParentsImpliesAParent :&lt;/p>&lt;p>self.isImpliedByParent implies VSpec.allInstances()-&amp;gt;exists(vSpec | vSpec.childVSpec-&amp;gt;includes(self))&lt;/p>&lt;p>####CVLSemanticEnd####&lt;/p>"/>
      </eAnnotations>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="defaultResolution" ordered="false"
          eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EBoolean"/>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="isImpliedByParent" ordered="false"
          lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EBoolean">
        <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
          <details key="documentation" value="&lt;p>&#xD;&#xA;    When True then resolving the parent VSpec positively implies resolving this VSpec positively. A VSpec resolution is&#xD;&#xA;    positive if it is a choice decided positively, or any classifier instantiation, or any value assignment to a&#xD;&#xA;    variable.&lt;br />&#xD;&#xA;    &lt;br />&#xD;&#xA;    For a root VSpec, True implies it must be resolved positively.&#xD;&#xA;&lt;/p>"/>
        </eAnnotations>
      </eStructuralFeatures>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="VSpec" abstract="true" eSuperTypes="#//cvl/VPackageable">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="&lt;p>A VSpec (Variability specification) indicates the existence of abstract variability, i.e. it indicate variability without defining the concrete consequences on the base model. Such consequences are specified via variation points and are related to variability specifications via bindings.&lt;br>&lt;br>VSpecs are organized as trees, representing logical constraints and guiding the materialization process. Each VSpec has a group multiplicity specifying upper and lower multiplicities against its children. The meaning of this is that each positive resolution against a VSpec must have a number of positive child resolutions conforming to the multiplicity interval. A VSpec resolution is positive if it is a choice decided positively, or any classifier instantiation, or any value assignment to a variable.&lt;/p>&lt;p>####CVLSemanticStart####&lt;/p>&lt;p>&lt;b>&lt;/b>Invariant :&lt;b>&lt;/b> If the VSpec has a multiplicity interval, it must have a number of children included between the lowerMultiplicity and the upperMultiplicity&lt;/p>&lt;p>&lt;b>&lt;/b>OCL :&lt;b>&lt;/b>&lt;/p>&lt;p>-- VSpec&lt;/p>&lt;p>-- nbChild_with_MultiplicityInterval :&lt;/p>&lt;p>--If the VSpec has a multiplicity interval, it must have a number of children included between the lowerMultiplicity and the upperMultiplicity&lt;/p>&lt;p>context VSpec :&lt;/p>&lt;p>inv nbChild_with_MultiplicityInterval :&lt;/p>&lt;p>if not self.groupMultiplicity-&amp;gt;isEmpty()&lt;/p>&lt;p>then (self.childVSpec-&amp;gt;size() &amp;gt;= self.groupMultiplicity.lower and self.groupMultiplicity.lower &amp;lt;&amp;gt; -1&lt;/p>&lt;p>and self.childVSpec-&amp;gt;size() &amp;lt;= self.groupMultiplicity.upper and self.groupMultiplicity.upper &amp;lt;&amp;gt; -1)&lt;/p>&lt;p>-- Infinite upper&lt;/p>&lt;p>or (self.groupMultiplicity.lower &amp;lt;&amp;gt; -1 and self.groupMultiplicity.upper == (-1) and self.childVSpec-&amp;gt;size() &amp;gt;= self.groupMultiplicity.lower )&lt;/p>&lt;p>-- Infinite lower : no sense for practical purposes&lt;/p>&lt;p>else true&lt;/p>&lt;p>endif&lt;/p>&lt;p>&lt;/p>&lt;p>####CVLSemanticEnd####&lt;/p>"/>
      </eAnnotations>
      <eStructuralFeatures xsi:type="ecore:EReference" name="groupMultiplicity" ordered="false"
          eType="#//cvl/MultiplicityInterval" containment="true">
        <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
          <details key="documentation" value="&lt;p>&#xD;&#xA;    The group multiplicity of the VSpec. If the VSpec is resolved positively and has a group multiplicity then the number&#xD;&#xA;    of&lt;br />&#xD;&#xA;    its children resolved positively must conform to the specified multiplicity interval.&#xD;&#xA;&lt;/p>"/>
        </eAnnotations>
      </eStructuralFeatures>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="resolutionTime" ordered="false"
          lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EString">
        <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
          <details key="documentation" value="&lt;p>The latest life-cycle stage at which this VSpec is expected to be resolved, e.g. &quot;Design&quot;, &quot;Link&quot;, &quot;Build&quot;, &quot;PostBuild&quot;, etc.&lt;/p>"/>
        </eAnnotations>
      </eStructuralFeatures>
      <eStructuralFeatures xsi:type="ecore:EReference" name="ownedVSpecDerivation"
          ordered="false" eType="#//cvl/VSpecDerivation" containment="true"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="child" ordered="false"
          upperBound="-1" eType="#//cvl/VSpec" containment="true"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="VPackageable" abstract="true">
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="name" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EString"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="MultiplicityInterval">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="&lt;p>A MultiplicityInterval specifies lower and upper multiplicities.&lt;/p>&lt;p>####CVLSemanticStart####&lt;/p>&lt;p>&lt;b>&lt;/b>Invariant :&lt;b>&lt;/b> The value of the lower multiplicity must be inferior or equal to the upper multiplicity&lt;/p>&lt;p>&lt;b>&lt;/b>OCL :&lt;b>&lt;/b>&lt;/p>&lt;p>-- MultiplicityInterval&lt;/p>&lt;p>-- lower_inferior_upper : The value of the lower multiplicity must be inferior or equal to the upper multiplicity&lt;/p>&lt;p>context MultiplicityInterval :&lt;/p>&lt;p>inv lower_inferior_upper :&lt;/p>&lt;p>(self.upper == (-1))&lt;/p>&lt;p>or (self.lower &amp;lt;&amp;gt; -1 and self.upper &amp;lt;&amp;gt; -1 and self.lower &amp;lt;= self.upper)&lt;/p>&lt;p>####CVLSemanticEnd####&lt;/p>"/>
      </eAnnotations>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="upper" ordered="false"
          lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EInt">
        <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
          <details key="documentation" value="&lt;p>&#xD;&#xA;    The upper multiplicity.&#xD;&#xA;&lt;/p>"/>
        </eAnnotations>
      </eStructuralFeatures>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="lower" ordered="false"
          lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EInt">
        <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
          <details key="documentation" value="&lt;p>&#xD;&#xA;    The lower multiplicity.&#xD;&#xA;&lt;/p>"/>
        </eAnnotations>
      </eStructuralFeatures>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="VSpecDerivation" eSuperTypes="#//cvl/VPackageable">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="&lt;p>A VSpec derivation is a specification how to derive the value a particular VSpec from other VSpecs during materialization.&lt;/p>"/>
      </eAnnotations>
      <eStructuralFeatures xsi:type="ecore:EReference" name="derivedVSpec" ordered="false"
          lowerBound="1" eType="#//cvl/VSpec">
        <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
          <details key="documentation" value="&lt;p>The VSpec whose value is derived by this derivation.&lt;/p>"/>
        </eAnnotations>
      </eStructuralFeatures>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="VClassifier" eSuperTypes="#//cvl/VSpec">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="&lt;p>&#xD;&#xA;    A VClassifier (variability classifier) is a kind of VSpec indicating the existence of variability whose resolution&#xD;&#xA;    involves instantiating it zero or more times and then resolving the variability of each instance separately. A&#xD;&#xA;    classifier may be bound to an executable variation point, in which case each resolution instance will execute the&#xD;&#xA;    variation point once. Each variability classifier has an instance multiplicity which specifies lower and upper limits&#xD;&#xA;    for the number of instances created from it.&#xD;&#xA;&lt;/p>"/>
      </eAnnotations>
      <eStructuralFeatures xsi:type="ecore:EReference" name="instanceMultiplicity"
          ordered="false" lowerBound="1" eType="#//cvl/MultiplicityInterval" containment="true">
        <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
          <details key="documentation" value="Specifies a cardinality constraint on the number of instances created from this VClassifier."/>
        </eAnnotations>
      </eStructuralFeatures>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="VSpecResolution" abstract="true" eSuperTypes="#//cvl/VPackageable">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="&lt;p>A VSpecResolution resolves a single VSpec. VSpecResolutions are organized as trees, mirroring the tree structure of the VSpecs they resolve, into which inherited VSpecs have been conceptually expanded.&lt;/p>&lt;p>####CVLSemanticStart####&lt;/p>&lt;p>&lt;b>&lt;/b>Invariant :&lt;b>&lt;/b> We must retrieve at least all of the resolvedVSpec's children associated with the VSpecResolution's vspec children&lt;/p>&lt;p>&lt;b>&lt;/b>OCL :&lt;b>&lt;/b>&lt;/p>&lt;p>-- VSpecResolution&lt;/p>&lt;p>-- We must retrieve at least all of the resolvedVSpec's children associated with the VSpecResolution's vspec children&lt;/p>&lt;p>-- So, the number of VSpecResolution's children must be &amp;gt;= to the number of resolvedVSpec' s children&lt;/p>&lt;p>context VSpecResolution&lt;/p>&lt;p>inv VSpecResChildrenCorrespondsToVSpecChildren :&lt;/p>&lt;p>self.childResolution-&amp;gt;size() &amp;gt;= self.resolvedVSpec.childVSpec-&amp;gt;size()&lt;/p>&lt;p>and&lt;/p>&lt;p>not (self.resolvedVSpec.childVSpec-&amp;gt;exists (vSpec | not (self.childResolution-&amp;gt;exists(vRes | vRes.resolvedVSpec == (VSpec)))))&lt;/p>&lt;p>####CVLSemanticEnd####&lt;/p>"/>
      </eAnnotations>
      <eStructuralFeatures xsi:type="ecore:EReference" name="resolvedVSpec" ordered="false"
          lowerBound="1" eType="#//cvl/VSpec">
        <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
          <details key="documentation" value="The&amp;nbsp;VSpec&amp;nbsp;this&amp;nbsp;VSpecResolution&amp;nbsp;resolves.Due to&amp;nbsp;VSpec inheritance and VClassifiers, a given VPSec&#xD;&#xA;may have several VSpecResolutions resolving it, where each resolution is in the context of its parent."/>
        </eAnnotations>
      </eStructuralFeatures>
      <eStructuralFeatures xsi:type="ecore:EReference" name="child" ordered="false"
          upperBound="-1" eType="#//cvl/VSpecResolution" containment="true">
        <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
          <details key="documentation" value="The child resolutions of this VSpecResolution. A given VSpecResolution is interpreted in the context of its parent."/>
        </eAnnotations>
      </eStructuralFeatures>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="ChoiceResolutuion" eSuperTypes="#//cvl/VSpecResolution">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="&lt;p>A ChoiceResolution is a VSpecResolution which resolves a single choice by deciding it positively (True) or negatively (False).&lt;/p>&lt;p>&lt;/p>&lt;p>####CVLSemanticStart####&lt;/p>&lt;p>Invariant&lt;/p>&lt;p>Invariant : If a choice is selected, the number of selected children must correspond to the multiplicity interval of the resolvedChoice&lt;/p>&lt;p>OCL :&lt;/p>&lt;p>-- ChoiceResolution&lt;/p>&lt;p>-- If a choice is selected, the number of selected children must correspond to the multiplicity interval of the resolvedChoice&lt;/p>&lt;p>context ChoiceResolutuion :&lt;/p>&lt;p>inv selectedChildrenMustCorrespondsToMultiplicityInterval :&lt;/p>&lt;p>if self.resolvedChoice.groupMultiplicity-&amp;gt;isEmpty()&lt;/p>&lt;p>then&lt;/p>&lt;p>(self.resolvedChoice.groupMultiplicity.upper &amp;lt;&amp;gt; (-1)&lt;/p>&lt;p>and self.resolvedChoice.groupMultiplicity.lower &amp;lt;= self.childResolution-&amp;gt;select (choiceRes | choiceRes.oclAsType(ChoiceResolutuion).decision)-&amp;gt;size()&lt;/p>&lt;p>and self.childResolution-&amp;gt;select (choiceRes | choiceRes.oclAsType(ChoiceResolutuion).decision)-&amp;gt;size() &amp;gt;= self.resolvedChoice.groupMultiplicity.upper&lt;/p>&lt;p>)&lt;/p>&lt;p>or&lt;/p>&lt;p>(self.resolvedChoice.groupMultiplicity.upper == (-1)&lt;/p>&lt;p>and self.resolvedChoice.groupMultiplicity.lower &amp;lt;= self.childResolution-&amp;gt;select (choiceRes | choiceRes.oclAsType(ChoiceResolutuion).decision)-&amp;gt;size()&lt;/p>&lt;p>)&lt;/p>&lt;p>else&lt;/p>&lt;p>-- no choice must be selected&lt;/p>&lt;p>self.childResolution-&amp;gt;select (choiceRes | choiceRes.oclAsType(ChoiceResolutuion).decision)-&amp;gt;isEmpty()&lt;/p>&lt;p>endif&lt;/p>&lt;p>Dynamic semantics&lt;/p>&lt;p>Pre and post condition&lt;/p>&lt;p>Pre-condition :&lt;/p>&lt;p>None&lt;/p>&lt;p>Post-condition:&lt;/p>&lt;p>After a Choice Resolution has been executed, the resolvedChoice is constained in the selected VSpecs set if the boolean decision is set to true, otherwise, the resolvedChoice is contained in the unselected VSpec set.&lt;/p>&lt;p>OCL :&lt;/p>&lt;p>-- ChoiceResolution&lt;/p>&lt;p>context ChoiceResolutuion::eval(ctx : CVLExecutionContext):&lt;/p>&lt;p>pre :&lt;/p>&lt;p>post :&lt;/p>&lt;p>self.decision implies&lt;/p>&lt;p>ctx.selectedVSpecs-&amp;gt;includes(self.resolvedChoice)&lt;/p>&lt;p>and not self.decision implies&lt;/p>&lt;p>ctx.unselectedVSpecs-&amp;gt;includes(self.resolvedChoice)&lt;/p>&lt;p>####CVLSemanticEnd####&lt;/p>"/>
      </eAnnotations>
      <eStructuralFeatures xsi:type="ecore:EReference" name="resolvedChoice" ordered="false"
          lowerBound="1" eType="#//cvl/Choice"/>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="decision" ordered="false"
          lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EBoolean">
        <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
          <details key="documentation" value="The yes/no decision resolving the choice."/>
        </eAnnotations>
      </eStructuralFeatures>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="VInstance" eSuperTypes="#//cvl/VSpecResolution">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="&lt;p>A VInstance is a VSpecResolution which resolves a VClassifer by instantiating it. The childResolutions of a VInstance resolve the variability for this specific instance of the VClassifier.&lt;/p>&lt;p>####CVLSemanticStart####&lt;/p>&lt;p>Invariant : &lt;/p>&lt;p>The number of childResolutions must be between the lowerMultiplicity and the upperMultiplicity of the instanceMultiplicity if it exists.&lt;/p>&lt;p>If the instance multiplicity does not exists, we have only one child.&lt;/p>&lt;p>OCL :&lt;/p>&lt;p>-- VInstance&lt;/p>&lt;p>-- nbChildResolution_with_instanceMultiplicity :&lt;/p>&lt;p>-- The number of childResolutions must be between the lowerMultiplicity and the upperMultiplicity of the instanceMultiplicity if it exists&lt;/p>&lt;p>-- If the instance multiplicity does not exists, we have only one child.&lt;/p>&lt;p>context VInstance :&lt;/p>&lt;p>inv nbChildResolution_with_instanceMultiplicity :&lt;/p>&lt;p>if not self.type.instanceMultiplicity-&amp;gt;isEmpty()&lt;/p>&lt;p>then (self.childResolution-&amp;gt;size() &amp;gt;= self.type.instanceMultiplicity.lower and self.type.instanceMultiplicity.lower &amp;lt;&amp;gt; -1&lt;/p>&lt;p>and self.childResolution-&amp;gt;size() &amp;lt;= self.type.instanceMultiplicity.upper and self.type.instanceMultiplicity.upper &amp;lt;&amp;gt; -1)&lt;/p>&lt;p>-- Infinite upper&lt;/p>&lt;p>or (self.type.instanceMultiplicity.lower &amp;lt;&amp;gt; -1 and self.type.instanceMultiplicity.upper == (-1) and self.childResolution-&amp;gt;size() &amp;gt;= self.type.instanceMultiplicity.lower )&lt;/p>&lt;p>-- infinite lower no sense for practical purposes&lt;/p>&lt;p>else&lt;/p>&lt;p>self.childResolution-&amp;gt;size() == (1)&lt;/p>&lt;p>endif&lt;/p>&lt;p>&lt;/p>&lt;p>Dynamic semantics&lt;/p>&lt;p>Pre and post condition&lt;/p>&lt;p>Pre-condition : &lt;/p>&lt;p>None &lt;/p>&lt;p>Post-condition: &lt;/p>&lt;p>After a VInstance has been executed, the associated VClassifier is contained in the selected VSpecs set.&lt;/p>&lt;p>OCL :&lt;/p>&lt;p>context VInstance::eval(ctx : CVLExecutionContext)&lt;/p>&lt;p>pre :&lt;/p>&lt;p>post : ctx.selectedVSpecs-&amp;gt;includes(self.type)&lt;/p>&lt;p>####CVLSemanticEnd####&lt;/p>"/>
      </eAnnotations>
      <eStructuralFeatures xsi:type="ecore:EReference" name="type" ordered="false"
          lowerBound="1" eType="#//cvl/VClassifier"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="VariationPoint" abstract="true" eSuperTypes="#//cvl/VPackageable">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="&lt;p>&#xD;&#xA;    A variation point is a concrete item of variability against the base model.&#xD;&#xA;&lt;/p>"/>
      </eAnnotations>
      <eStructuralFeatures xsi:type="ecore:EReference" name="bindingVspec" ordered="false"
          upperBound="-1" eType="#//cvl/VSpec">
        <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
          <details key="documentation" value="&lt;p>The VSpecs to which the variation point is bound.&lt;/p>"/>
        </eAnnotations>
      </eStructuralFeatures>
      <eStructuralFeatures xsi:type="ecore:EReference" name="precedenceConstraint"
          upperBound="-1" eType="#//cvl/VariationPoint"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="FragmentSubstitution" eSuperTypes="#//cvl/ChoiceVariationPoint #//cvl/RepeatableVariationPoint">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="&lt;p>Fragment Substitution substitutes a placement fragment of the base model with one or more replacement fragments of the base model.&lt;/p>&lt;p>Constraints:&lt;/p>&lt;p>The boundary elements define all references going in and out of the placement fragment. The boundary elements fully define all references going in and out of the replacement fragment.&lt;/p>&lt;p>Semantics:&lt;/p>&lt;p>1. Delete the model elements defined by the PlacementFragment. The placement model elements can be found through FragmentSubstitution.placement's placementBoundaryElements that are of class ToPlacement (using the model element references called insideBoundaryElement) and the transitive closure of all references from these, where the traversal is cut off at any reference that has the same value as any of FragmentSubstitution.placement's PlacementBoundardyElement that are of class FromPlacement (using the model element references called outsideBoundaryElement).&lt;/p>&lt;p>&lt;br>2. For the replacement fragments, copy its content onto the hole made by the deletion of the placement fragment. The placement and replacement boundary elements must correspond. The content model elements can be found through FragmentSubstitution. replacement's ReplacementBoundaryElement that are of type ToReplacement (using the model element references called insideBoundaryElement) and all model elements found through the transitive closure of all references from this set of model elements, where the traversal is cut off at any reference that has the same value as any of FragmentSubstitution.replacement's ReplacementBoundaryElement that are of type FromReplacement (using the model element references called outsideBoundaryElement).&lt;/p>&lt;p>If multi is true, then a number of copies of the replacement fragment will be copied onto the placement. The resolution model will define how many.&lt;/p>&lt;p>Any substitutions addressing placements inside the given replacement fragment will be performed on the copy of the replacement fragment which is the last one generated.&lt;/p>&lt;p>3. Binding boundary elements. The placement and replacement boundary elements are connected by bindings. The bindings are given by the BoundaryElementBindings:&lt;br>1. FromBinding: fromReplacement.insideBoundaryElement.propertyName[] = fromPlacement.outsideBoundaryElement[]&lt;br>2. ToBinding: toPlacement.outsideBoundaryElement.propertyName[] = toReplacement.insideBoundaryElement[]. This definition in fact also covers attributes that have multiplicity. Such attributes may be seen as arrays or collections, and repeated reference assignments to such attributes during variability transformation will mean adding a new individual reference to the identifier collection.&lt;/p>&lt;p>####CVLSemanticStart####&lt;/p>&lt;p>&lt;/p>&lt;p>Dynamic semantics&lt;/p>&lt;p>Pre and post condition&lt;/p>&lt;p>Pre-condition : &lt;/p>&lt;p>Before the execution of a Fragment Substitution, the placement fragment must exist in the base model.&lt;/p>&lt;p>Post-condition: &lt;/p>&lt;p>After a FragmentSubstitution has been executed, the placement elements cannot be found in the resolved model whereas the replacement elements are in the resolved model.&lt;/p>&lt;p>OCL :&lt;/p>&lt;p>context FragmentSubstitution::eval(ctx : CVLExecutionContext)&lt;/p>&lt;p>pre : &lt;/p>&lt;p>self.boundaryElementBinding-&amp;gt;forAll(boundaryElt |boundaryElt.oclIsTypeOf(ToBinding) implies boundaryElt.oclAsType(ToBinding).toPlacement.insideBoundaryElement-&amp;gt;forAll(e |  ctx.resolvedModelElements-&amp;gt;includes(e)) )&lt;/p>&lt;p>post :&lt;/p>&lt;p> self.boundaryElementBinding-&amp;gt;forAll(boundaryElt |boundaryElt.oclIsTypeOf(ToBinding) implies boundaryElt.oclAsType(ToBinding).toPlacement.insideBoundaryElement-&amp;gt;forAll(e | not ctx.resolvedModelElements-&amp;gt;includes(e)) )&lt;/p>&lt;p>           and self.boundaryElementBinding-&amp;gt;forAll(boundaryElt |boundaryElt.oclIsTypeOf(ToBinding) implies boundaryElt.oclAsType(ToBinding).toReplacement.insideBoundaryElement-&amp;gt;forAll(e |  ctx.resolvedModelElements-&amp;gt;includes(e)) )&lt;/p>&lt;p>Note : FragmentSubstitution needs the use of FromBinding and ToBinding metaclasses (please refer to the corresponding pre and post conditions).&lt;/p>&lt;p>####CVLSemanticEnd####&lt;/p>&lt;p>&lt;/p>"/>
      </eAnnotations>
      <eStructuralFeatures xsi:type="ecore:EReference" name="boundaryElementBinding"
          ordered="false" upperBound="-1" eType="#//cvl/BoundaryElementBinding" containment="true">
        <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
          <details key="documentation" value="&lt;p>&#xD;&#xA;    Specifies the binding between the placement and replacement fragments.&#xD;&#xA;&lt;/p>"/>
        </eAnnotations>
      </eStructuralFeatures>
      <eStructuralFeatures xsi:type="ecore:EReference" name="placement" ordered="false"
          lowerBound="1" eType="#//cvl/PlacementFragment">
        <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
          <details key="documentation" value="&lt;p>&#xD;&#xA;    Specifies the fragment to be replaced.&#xD;&#xA;&lt;/p>"/>
        </eAnnotations>
      </eStructuralFeatures>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="multi" ordered="false"
          lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EBoolean"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="replacement" ordered="false"
          eType="#//cvl/ReplacementFragmentType"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="ChoiceVariationPoint" abstract="true"
        eSuperTypes="#//cvl/VariationPoint">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="&lt;p>A choice variation point is a variation point which can be applied/executed or not. It must be bound to a choice VSpec deciding whether or not it will be applied/executed.&lt;/p>"/>
      </eAnnotations>
      <eStructuralFeatures xsi:type="ecore:EReference" name="bindingChoice" ordered="false"
          upperBound="-1" eType="#//cvl/Choice"/>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="mappingExpression" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EString"/>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="expression" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EString"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="RepeatableVariationPoint" abstract="true"
        eSuperTypes="#//cvl/VariationPoint">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="&lt;p>An instantiable variation point is a variation point which can be instantiated, i.e. applied zero or more times. It must be bound to a classifier VSpec &lt;/p>"/>
      </eAnnotations>
      <eStructuralFeatures xsi:type="ecore:EReference" name="bindingClassifier" ordered="false"
          eType="#//cvl/VClassifier"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="BoundaryElementBinding" abstract="true">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="Specifies the binding between the boundary elements of the placement fragment and the replacement fragment."/>
      </eAnnotations>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="PlacementFragment" eSuperTypes="#//cvl/VariationPoint">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="A PlacementFragment defines a fragment (set of model elements) of the base model that will be replaced by a&#xD;&#xA;ReplacementFragment during the variability transformation. The set of model elements of the fragment will be deleted."/>
      </eAnnotations>
      <eStructuralFeatures xsi:type="ecore:EReference" name="placementBoundaryElement"
          ordered="false" upperBound="-1" eType="#//cvl/PlacementBoundaryElement"
          containment="true">
        <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
          <details key="documentation" value="The boundary elements captures all the relations from and to the fragment."/>
        </eAnnotations>
      </eStructuralFeatures>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="PlacementBoundaryElement" abstract="true">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="Represents the boundary between a placement fragment and the rest of the base model."/>
      </eAnnotations>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="ReplacementFragmentType" eSuperTypes="#//cvl/Variabletype">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="&lt;p>Replacement Fragment Type defines a fragment of the base model that will be used as replacement for some placement fragment&lt;br>of the base model.&lt;/p>&lt;p>Constraints:&lt;/p>&lt;p>The placements contained in a replacement fragments should only involve model elements which are inside the replacement fragment. These placements can be used in all instances of a replacement fragment.&lt;/p>&lt;p>Semantics:&lt;/p>&lt;p>The semantics of Replacement Fragment Type can be found under Fragment Substitution.&lt;/p>&lt;p>####CVLSemanticStart####&lt;/p>&lt;p>Invariant :&lt;/p>&lt;p>OCL :&lt;/p>&lt;p>&lt;/p>&lt;p>####CVLSemanticEnd####&lt;/p>&lt;p>&lt;/p>"/>
      </eAnnotations>
      <eStructuralFeatures xsi:type="ecore:EReference" name="replacementBoundaryElement"
          ordered="false" upperBound="-1" eType="#//cvl/ReplacementBoundaryElement"
          containment="true">
        <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
          <details key="documentation" value="The boundary elements captures all the relations from and to the fragment."/>
        </eAnnotations>
      </eStructuralFeatures>
      <eStructuralFeatures xsi:type="ecore:EReference" name="placementFragment" ordered="false"
          upperBound="-1" eType="#//cvl/PlacementFragment" containment="true">
        <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
          <details key="documentation" value="Set of placements contained by the replacement fragment."/>
        </eAnnotations>
      </eStructuralFeatures>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="Variabletype" abstract="true" eSuperTypes="#//cvl/VPackageable"/>
    <eClassifiers xsi:type="ecore:EClass" name="ReplacementBoundaryElement" abstract="true">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="Represents the boundary between a replacement fragment and the rest of the base model."/>
      </eAnnotations>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="ObjectSubstitution" eSuperTypes="#//cvl/ChoiceVariationPoint">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="&lt;p>An ObjectSubstitution is choice variation point which specifies that an object of the base model, called the replacement, may be substituted for another, called the placement.&lt;br>&lt;br>The placement and replacement objects are specified via object handles identifying a base model objects.&lt;br>&lt;br>An ObjectSubstitution must be bound to a choice deciding whether or not it will be executed. It may not be bound to a VClassifier or variable.&lt;/p>&lt;p>####CVLSemanticStart####&lt;/p>&lt;p>Invariant : An ObjectSubstitution may not be bound to a VClassifier&lt;/p>&lt;p>OCL :&lt;/p>&lt;p>-- ObjectSubstitution&lt;/p>&lt;p>-- An ObjectSubstitution may not be bound to a VClassifier&lt;/p>&lt;p>context ObjectSubstitution :&lt;/p>&lt;p>inv notBoundToAVClassifier :&lt;/p>&lt;p>not (self.bindingVspec-&amp;gt;exists( vspec | vspec.oclIsTypeOf(VClassifier)))&lt;/p>&lt;p>Dynamic semantics&lt;/p>&lt;p>Pre and post conditions&lt;/p>&lt;p>Pre-condition : &lt;/p>&lt;p>Before the execution of an ObjectSubstitution, placement and replacement object must exist in the base model.&lt;/p>&lt;p>Post-condition: &lt;/p>&lt;p>After an Object Substitution has been executed, the replacement object must exist in the resolved model whereas the placement object cannot be found in the resolved model.&lt;/p>&lt;p>OCL :&lt;/p>&lt;p>-- ObjectSubstitution&lt;/p>&lt;p>context ObjectSubstitution::eval(ctx : CVLExecutionContext)&lt;/p>&lt;p>pre:&lt;/p>&lt;p>ctx.resolvedModelElements-&amp;gt;includes( self.placementObject)&lt;/p>&lt;p>and ctx.resolvedModelElements-&amp;gt;includes( self.replacementObject)&lt;/p>&lt;p>post:&lt;/p>&lt;p>ctx.resolvedModelElements-&amp;gt;includes( self.replacementObject)&lt;/p>&lt;p>and not ctx.resolvedModelElements-&amp;gt;includes( self.placementObject)&lt;/p>&lt;p>&lt;/p>&lt;p>####CVLSemanticEnd####&lt;/p>"/>
      </eAnnotations>
      <eStructuralFeatures xsi:type="ecore:EReference" name="placementObject" ordered="false"
          lowerBound="1" eType="#//cvl/ObjectHandle" containment="true">
        <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
          <details key="documentation" value="The&amp;nbsp;object handle identifying the base model object&amp;nbsp;to&amp;nbsp;be&amp;nbsp;replaced&amp;nbsp;by&amp;nbsp;the replacement&#xD;&#xA;object&amp;nbsp;in&amp;nbsp;this&amp;nbsp;substitution."/>
        </eAnnotations>
      </eStructuralFeatures>
      <eStructuralFeatures xsi:type="ecore:EReference" name="replacementObject" ordered="false"
          lowerBound="1" eType="#//cvl/ObjectHandle" containment="true">
        <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
          <details key="documentation" value="The&amp;nbsp;object handle identifying the base model object&amp;nbsp;replacing&amp;nbsp;to&amp;nbsp;the&amp;nbsp;placement&amp;nbsp;object in this&#xD;&#xA;substitution. If no replacement is specified then the object is expected to arrive in a variable, that is the variation&#xD;&#xA;point must be bound to a variable to be acted on."/>
        </eAnnotations>
      </eStructuralFeatures>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="ObjectHandle" eSuperTypes="#//cvl/BaseModelHandle">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="&lt;p>&#xD;&#xA;    An object handle identifies an object of the base model. This Class abstracts over the cross-domain referencing&#xD;&#xA;    mechanism needed to refer from CVL elements to base model objects.&#xD;&#xA;&lt;/p>"/>
      </eAnnotations>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="MOFRef" ordered="false"
          lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EString"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="BaseModelHandle">
      <eStructuralFeatures xsi:type="ecore:EReference" name="reference" eType="ecore:EClass http://www.eclipse.org/emf/2002/Ecore#//EObject"/>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="referenceString" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EString"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="Existence" abstract="true" eSuperTypes="#//cvl/ChoiceVariationPoint">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="Existence is a kind of variation point which indicates that an element of the base model may or may not exist in the&#xD;&#xA;materialized model."/>
      </eAnnotations>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="Variable" eSuperTypes="#//cvl/VSpec">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="&lt;p>&#xD;&#xA;    A variable is a kind of VSpec indicating value variability, that is the fact that some externally-obtained value is to&#xD;&#xA;    be inserted into the base model. Resolving the variable means providing such value. Variables may be bound to variation&#xD;&#xA;    points which require values, for example slot value assignment.&#xD;&#xA;&lt;/p>"/>
      </eAnnotations>
      <eStructuralFeatures xsi:type="ecore:EReference" name="replacementFragmentTypesubsetstype"
          ordered="false" eType="#//cvl/ReplacementFragmentType"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="defaulValue" ordered="false"
          eType="#//cvl/ValueSpecification" containment="true"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="type" ordered="false"
          lowerBound="1" eType="#//cvl/Variabletype"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="ValueSpecification" abstract="true">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="&lt;p>&#xD;&#xA;    A ValueSpecification specifies a value which is either primitive, or an object of the base mode,&amp;nbsp;or a fragment of&#xD;&#xA;    the base model.&amp;nbsp;&#xD;&#xA;&lt;/p>"/>
      </eAnnotations>
      <eStructuralFeatures xsi:type="ecore:EReference" name="type" ordered="false"
          lowerBound="1" eType="#//cvl/Variabletype"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="VariableValueAssignment" eSuperTypes="#//cvl/VSpecResolution">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="&lt;p>A VariableValueAssignment is a VSpecResolution which resolves a variables by providing a value of the variable's type.&lt;/p>&lt;p>&lt;/p>&lt;p>####CVLSemanticStart####&lt;/p>&lt;p>&lt;/p>&lt;p>Dynamic semantics&lt;/p>&lt;p>Pre and post condition&lt;/p>&lt;p>Pre-condition :&lt;/p>&lt;p>Before the execution of a VariableValueAssignment, the variable stored in the VariableValueAssignment must exist in the variable dictionary.&lt;/p>&lt;p>Post-condition:&lt;/p>&lt;p>After a VariableValueAssignment has been executed, the resolvedVariable is assigned with the value.&lt;/p>&lt;p>&lt;/p>&lt;p>OCL :&lt;/p>&lt;p>context VariableValueAssignment::eval(ctx : CVLExecutionContext) :&lt;/p>&lt;p>pre: not ctx.variabledictionary-&amp;gt;exists(p | p.elements-&amp;gt;exists ( k | k.key == (self.resolvedVariable.name)))&lt;/p>&lt;p>post: ctx.variabledictionary-&amp;gt;exists(p | p.elements-&amp;gt;exists ( k| k.key == (self.resolvedVariable.name) and k.value == (self.value)) )&lt;/p>&lt;p>####CVLSemanticEnd####&lt;/p>&lt;p>&lt;/p>&lt;p>&lt;/p>&lt;p>&lt;/p>&lt;p>&lt;/p>&lt;p>&lt;/p>&lt;p>&lt;/p>&lt;p>&lt;/p>"/>
      </eAnnotations>
      <eStructuralFeatures xsi:type="ecore:EReference" name="resolvedVariable" ordered="false"
          lowerBound="1" eType="#//cvl/Variable"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="value" ordered="false"
          lowerBound="1" eType="#//cvl/ValueSpecification" containment="true"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="PrimitveType" eSuperTypes="#//cvl/Variabletype">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="A type of a variable which is either String, Integer, Float, or Boolean."/>
      </eAnnotations>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="type" ordered="false"
          lowerBound="1" eType="#//cvl/PrimitiveTypeEnum"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="ObjectType" eSuperTypes="#//cvl/Variabletype">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="A type of objects in the base model, specified as a metaclass in the metamodel of which the base model in an instance."/>
      </eAnnotations>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="metaClass" ordered="false"
          lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EString">
        <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
          <details key="documentation" value="The name of the metaclass in the metamodel of which the base model is an instance."/>
        </eAnnotations>
      </eStructuralFeatures>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="VInterface" eSuperTypes="#//cvl/VPackageable">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="&lt;p>A VInterface is a collection of VSpecs. Each CVSpec has a VInterface which lists the VSPecs that need be resolved in order to resolve the CVspec. When a configurable unit is bout to a CVspec, its extension is the interface exposed by the unit. &lt;/p>"/>
      </eAnnotations>
      <eStructuralFeatures xsi:type="ecore:EReference" name="member" ordered="false"
          upperBound="-1" eType="#//cvl/VSpec" containment="true">
        <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
          <details key="documentation" value="&lt;p>The members of the interface.&lt;/p>"/>
        </eAnnotations>
      </eStructuralFeatures>
      <eStructuralFeatures xsi:type="ecore:EReference" name="ownedConstraint" ordered="false"
          upperBound="-1" eType="#//cvl/Constraint" containment="true">
        <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
          <details key="documentation" value="Constraints&amp;nbsp;over&amp;nbsp;the&amp;nbsp;VSPecs&amp;nbsp;over&amp;nbsp;this&amp;nbsp;VInterface"/>
        </eAnnotations>
      </eStructuralFeatures>
      <eStructuralFeatures xsi:type="ecore:EReference" name="super" ordered="false"
          eType="#//cvl/VInterface">
        <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
          <details key="documentation" value="&lt;p>An inherited interface. &lt;/p>"/>
        </eAnnotations>
      </eStructuralFeatures>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="Constraint" eSuperTypes="#//cvl/VPackageable">
      <eStructuralFeatures xsi:type="ecore:EReference" name="context" ordered="false"
          eType="#//cvl/VSpec"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="SlotAssignment" eSuperTypes="#//cvl/ChoiceVariationPoint">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="&lt;p>A slot assignment is a choice variation point which specifies that a value may be assigned to a particular slot in a particular object in the base model. The object is identified via an object handle pointing to the base model, and the slot is identified via a string representing a MOF property owned by the class of which the object is an instance. The value to be assigned is specified explicitly. The variation point must be bound to a choice deciding whether or not to assign the value, in order to be acted on.&lt;br>&lt;br>A slot assignment may not be bound to a VClassifer or variable.&lt;/p>&lt;p>&lt;/p>&lt;p>####CVLSemanticStart####&lt;/p>&lt;p>Invariant&lt;/p>&lt;p>&lt;b>&lt;/b>Invariant :&lt;b>&lt;/b> The property named as self.slotIdentifier must exist in the slotOwner object&lt;/p>&lt;p>&lt;b>&lt;/b>OCL :&lt;b>&lt;/b>&lt;/p>&lt;p>-- SlotAssigmnent&lt;/p>&lt;p>-- The property named as self.slotIdentifier must exist in the slotOwner object&lt;/p>&lt;p>context SlotAssignment :&lt;/p>&lt;p>inv propertyIn_slotOwner :&lt;/p>&lt;p>if self.SlotOwner &amp;lt;&amp;gt; null&lt;/p>&lt;p>then&lt;/p>&lt;p>self.SlotOwner.getPropertyByName(self.slotIdentifier) &amp;lt;&amp;gt; null&lt;/p>&lt;p>else&lt;/p>&lt;p>-- if SlotOwner does not exists neither the property&lt;/p>&lt;p>false&lt;/p>&lt;p>endif&lt;/p>&lt;p>Dynamic semantics&lt;/p>&lt;p>Pre and post condition&lt;/p>&lt;p>Pre-condition : &lt;/p>&lt;p>Before the execution of a SlotAssignment, the SlotOwner object must exist in the base model and it must have a MOF property called as in the slotIdentifier.&lt;/p>&lt;p>Post-condition: &lt;/p>&lt;p>After a SlotAssignment has been executed, the MOF property called as in the slotIdentifier in the SlotOwner has been assigned with the value value.&lt;/p>&lt;p>Note : To express more easily this OCL pre condition, we add the operations getPropertyByName(String propertyName) and getPropertyValue(String propertyName) on the ObjectHandle metaclass to obtain respectively the property with the given name and the value associated with this property.&lt;/p>&lt;p>OCL :&lt;/p>&lt;p>context SlotAssignment::eval(ctx : CVLExecutionContext) &lt;/p>&lt;p>pre : self.SlotOwner &amp;lt;&amp;gt; null and ctx.resolvedModelElements-&amp;gt;includes(self.SlotOwner) and self.SlotOwner-&amp;gt;asOrderedSet()-&amp;gt;first().getPropertyByName(self.slotIdentifier) &amp;lt;&amp;gt; null&lt;/p>&lt;p>post : self.SlotOwner-&amp;gt;asOrderedSet()-&amp;gt;first().getPropertyValue(self.slotIdentifier)-&amp;gt;asOrderedSet()-&amp;gt;first() == (self.value)&lt;/p>&lt;p>####CVLSemanticEnd####&lt;/p>"/>
      </eAnnotations>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="slotIdentifier" ordered="false"
          lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EString">
        <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
          <details key="documentation" value="The name of the MOF Property&amp;nbsp;in the object's metaclass identifying the slot to which the value is to be assigned."/>
        </eAnnotations>
      </eStructuralFeatures>
      <eStructuralFeatures xsi:type="ecore:EReference" name="value" ordered="false"
          eType="#//cvl/ValueSpecification" containment="true">
        <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
          <details key="documentation" value="The value to be assigned."/>
        </eAnnotations>
      </eStructuralFeatures>
      <eStructuralFeatures xsi:type="ecore:EReference" name="SlotOwner" ordered="false"
          lowerBound="1" eType="#//cvl/ObjectHandle" containment="true">
        <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
          <details key="documentation" value="The object handle identifying the base model object to whose slot the value is to be assigned."/>
        </eAnnotations>
      </eStructuralFeatures>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="FixedSlotValueAssignment"/>
    <eClassifiers xsi:type="ecore:EClass" name="FixedObjectSubstitution"/>
    <eClassifiers xsi:type="ecore:EClass" name="ObjectExistence" eSuperTypes="#//cvl/Existence">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="&lt;p>ObjectExistence is a kind of choice variation point which indicates that an object of the base model may or may not exist in the materialized model. The object is identified via an object handle.&lt;br>&lt;br>To be acted on, an ObjectExistence variation point must be bound to a choice deciding whether or not the object will be present in the materialized model. It may not be bound to a variable or to a classifier.&lt;/p>&lt;p>&lt;/p>&lt;p>####CVLSemanticStart####&lt;/p>&lt;p>Invariant&lt;/p>&lt;p>Invariant : An ObjectExistence must be bound to a Choice, not to a variable or to a classifier&lt;/p>&lt;p>OCL : &lt;/p>&lt;p>-- ObjectExistence&lt;/p>&lt;p>-- An ObjectExistence must be bound to a Choice, not to a variable or to a classifier&lt;/p>&lt;p>context ObjectExistence :&lt;/p>&lt;p>inv must_bound_to_choice :&lt;/p>&lt;p>(self.bindingVspec-&amp;gt;exists( vspec | vspec.oclIsTypeOf(Choice)))&lt;/p>&lt;p>and not ( (self.bindingVspec-&amp;gt;exists( vspec | vspec.oclIsTypeOf(Variable))))&lt;/p>&lt;p>and not ( (self.bindingVspec-&amp;gt;exists( vspec | vspec.oclIsTypeOf(VClassifier))))&lt;/p>&lt;p>Dynamic semantics&lt;/p>&lt;p>Pre and post condition&lt;/p>&lt;p>Pre-condition : &lt;/p>&lt;p>None&lt;/p>&lt;p>Post-condition: &lt;/p>&lt;p>After an ObjectExistence has been executed, the optionalObject must be in the resolved model otherwise it cannot be in the resolved model.&lt;/p>&lt;p>OCL :&lt;/p>&lt;p>-- ObjectExistence&lt;/p>&lt;p>context ObjectExistence::eval(ctx : CVLExecutionContext)&lt;/p>&lt;p>pre :&lt;/p>&lt;p>post: &lt;/p>&lt;p>ctx.selectedVSpecs-&amp;gt;includes(self.bindingVspec-&amp;gt;asOrderedSet()-&amp;gt;first()) implies ctx.resolvedModelElements-&amp;gt;includes(self.optionalObject) and&lt;/p>&lt;p>ctx.unselectedVSpecs-&amp;gt;includes((self.bindingVspec-&amp;gt;asOrderedSet()-&amp;gt;first())) implies not ctx.resolvedModelElements-&amp;gt;includes(self.optionalObject)&lt;/p>&lt;p>####CVLSemanticEnd####&lt;/p>"/>
      </eAnnotations>
      <eStructuralFeatures xsi:type="ecore:EReference" name="optionalObject" ordered="false"
          lowerBound="1" upperBound="-1" eType="#//cvl/ObjectHandle" containment="true">
        <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
          <details key="documentation" value="The&amp;nbsp;object&amp;nbsp;handle&amp;nbsp;identifying&amp;nbsp;the&amp;nbsp;base&amp;nbsp;model&amp;nbsp;object&amp;nbsp;whose&amp;nbsp;existence&amp;nbsp;is&amp;nbsp;in&amp;nbsp;question."/>
        </eAnnotations>
      </eStructuralFeatures>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="LinkAssignment" eSuperTypes="#//cvl/ChoiceVariationPoint">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="&lt;p>A LinkAssignmet is a choice variation point which specifies that an object in the base model, called the replacement, may be substituted for another as the end of a particular link in the base model.&lt;br>&lt;br>The link-end is identified via a link handle pointing to the base model plus a string representing a MOF property owned by the association of which the link is an instance. The placement is specified via an object handle.&lt;br>The variation point must be bound to a choice deciding whether or not it will be executed to be acted on. It may not be bound to a variable or classifier.&lt;/p>&lt;p>####CVLSemanticStart####&lt;/p>&lt;p>Dynamic semantics&lt;/p>&lt;p>Pre and post condition&lt;/p>&lt;p>Pre-condition : &lt;/p>&lt;p>None&lt;/p>&lt;p>Post-condition: &lt;/p>&lt;p>After a Link Assignment has been executed, the newEnd object handle must be an end of the LinkHandle link.&lt;/p>&lt;p>&lt;/p>&lt;p>Note : To express more easily this OCL pre condition, we add an operation getEnd() on the LinkHandle metaclass. This operation computes the respective end of this linkHandle.&lt;/p>&lt;p>OCL :&lt;/p>&lt;p>-- LinkAssignment &lt;/p>&lt;p>context LinkAssignment::eval(ctx : CVLExecutionContext)&lt;/p>&lt;p>pre :&lt;/p>&lt;p>post : self.link.getEnd()-&amp;gt;includes(self.newEnd)&lt;/p>&lt;p>####CVLSemanticEnd####&lt;/p>"/>
      </eAnnotations>
      <eStructuralFeatures xsi:type="ecore:EReference" name="link" ordered="false"
          lowerBound="1" eType="#//cvl/LinkHandle" containment="true"/>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="linkEndIdentifier" ordered="false"
          lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EString">
        <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
          <details key="documentation" value="The name of the MOF Property&amp;nbsp;in the object's metaclass identifying the link-end where this substitution occurs."/>
        </eAnnotations>
      </eStructuralFeatures>
      <eStructuralFeatures xsi:type="ecore:EReference" name="newEnd" ordered="false"
          lowerBound="1" eType="#//cvl/ObjectHandle" containment="true">
        <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
          <details key="documentation" value="The&amp;nbsp;object handle identifying the base model object&amp;nbsp;replacing&amp;nbsp;the link-end in this substitution. If no&#xD;&#xA;replacement is specified then the object is expected to arrive in a variable, that is the variation point must be bound to&#xD;&#xA;a variable to be acted on."/>
        </eAnnotations>
      </eStructuralFeatures>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="LinkHandle" eSuperTypes="#//cvl/BaseModelHandle">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="&lt;p>&#xD;&#xA;    A link handle identifies a link of the base model. This Class abstracts over the cross-domain referencing mecahnism&#xD;&#xA;    needed to refer from CVL elements to base model links.&#xD;&#xA;&lt;/p>"/>
      </eAnnotations>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="MOFRef" ordered="false"
          lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EString"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="ConfigurableUnit" eSuperTypes="#//cvl/CompositeVariationPoint">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="&lt;p>&lt;span style=&quot;font-size:10pt;&quot;>A configurable unit (CU) represents &lt;span style=&quot;color:#000000;&quot;>a base model object which is a cohesive unit of variability, configurable as a whole&lt;/span>. The base model object is a container of other base model elements – objects and links – and the CVL configurable unit is a container of variation points defined against those elements, variability specifications, and bindings between them. For example, a configurable unit may have associated with it a UML package and contain variation points defined over elements in that package.&lt;/span>&lt;/p>&lt;p>&lt;span style=&quot;font-size:10pt;&quot;>A CU may be encapsulated or not. An encapsulated CU is black-box with respect to its internal variability. It exposes to the external world a variability interface, which is a VSpec tree or trees. The configurable unit may then be configured by providing resolutions to those VSpecs, not its internal ones. Resolutions for the internal VSpecs are derived through a variability mapping between the internal VSpecs and the VSpecs on the interface. Mappings are logical implications between VSpecs and should not be confused with bindings, which tie VSpecs to variation points. A non-encapsulated CU does not expose a variability interface and is configured via configurations which directly resolve its internal VSpecs. In any case, each CU has a derived variability type. For encapsulated CUs the variability type is the set of VSpecs in the explicitly exposed interface. For a non-encapsulated CU the variability type is the set of internal VSpecs.&lt;br>&lt;br>Conceptually, a configurable unit and the base model object associated with it are one unified entity representing a base model container with variability on its internal content. So the UML package above may be thought of as being configurable though technically it is an external CVL element referencing the object through a handle.&lt;br>&lt;br>CVL configurable units may contain other units, re-iterating the modular structure of the base model. For example, a UML package and a contained class may both be configurable, which means there will be two CVL configurable units, one for the package and one for the class, where the unit for the package contains that for the class. It may further be specified that materialization of the class is triggered by materialization of the package, using a configuration connector.&lt;/span>&lt;/p>&lt;p>&lt;span style=&quot;font-size:10pt;&quot;>####CVLSemanticStart####&lt;/span>&lt;/p>&lt;p>Invariant : &lt;/p>&lt;p >Elements contained in the Configurable Unit associated with a given CVSpec must only point on elements in Interface associated with this given CVSpec&lt;/p>&lt;p>&lt;/p>&lt;p>OCL :&lt;/p>&lt;p>&lt;/p>&lt;p>-- ConfigurableUnit &lt;/p>&lt;p>-- Elements contained in the Configurable Unit associated with a given CVSpec must only point on elements&lt;/p>&lt;p>-- in Interface associated with this given CVSpec&lt;/p>&lt;p>context ConfigurableUnit :&lt;/p>&lt;p>def : isContained ( in vps : VSpec ) : Boolean = &lt;/p>&lt;p>                        self.bindingCVSpec.vInterface.vSpec-&amp;gt;exists(v | v = vps &lt;/p>&lt;p>                        or &lt;/p>&lt;p>                        (  if   not (v.childVSpec-&amp;gt;isEmpty())&lt;/p>&lt;p>                                        then&lt;/p>&lt;p>                                                v.childVSpec-&amp;gt;exists (child | isContained (child) = true)&lt;/p>&lt;p>                                        endif&lt;/p>&lt;p>                                 )&lt;/p>&lt;p>                        )&lt;/p>&lt;p>inv consistencyInInterfacePointedByCVSpec : &lt;/p>&lt;p>        not (self.ownedVariationPoint-&amp;gt;exists (vp | &lt;/p>&lt;p>                        -- search in the VSpec&lt;/p>&lt;p>                        ( vp.bindingVspec-&amp;gt;exists ( vsp | not isContained(vsp) ) )&lt;/p>&lt;p>                ))&lt;/p>&lt;p>####CVLSemanticEnd####&lt;/p>"/>
      </eAnnotations>
      <eStructuralFeatures xsi:type="ecore:EReference" name="ownedVSpec" ordered="false"
          upperBound="-1" eType="#//cvl/VSpec" containment="true">
        <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
          <details key="documentation" value="&lt;p>Internal VSpecs of the CU&lt;/p>"/>
        </eAnnotations>
      </eStructuralFeatures>
      <eStructuralFeatures xsi:type="ecore:EReference" name="ownedVariationPoint"
          ordered="false" upperBound="-1" eType="#//cvl/VariationPoint" containment="true">
        <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
          <details key="documentation" value="Internal variation points against the content of the base model object referenced by the unit."/>
        </eAnnotations>
      </eStructuralFeatures>
      <eStructuralFeatures xsi:type="ecore:EReference" name="ownedConstraint" ordered="false"
          upperBound="-1" eType="#//cvl/Constraint" containment="true">
        <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
          <details key="documentation" value="The constraints wrt the internal VSPecs of the unit."/>
        </eAnnotations>
      </eStructuralFeatures>
      <eStructuralFeatures xsi:type="ecore:EReference" name="configurableContainerObject"
          ordered="false" lowerBound="1" eType="#//cvl/ObjectHandle" containment="true">
        <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
          <details key="documentation" value="&lt;p>The container object in the base model which is configurable.&lt;/p>"/>
        </eAnnotations>
      </eStructuralFeatures>
      <eStructuralFeatures xsi:type="ecore:EReference" name="ownedVSpecResolution"
          ordered="false" upperBound="-1" eType="#//cvl/VSpecResolution" containment="true"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="unitInterface" ordered="false"
          lowerBound="1" eType="#//cvl/VInterface">
        <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
          <details key="documentation" value="&lt;p>The interface of the unit. Derived as the extension of the binding CVSpec.&lt;/p>"/>
        </eAnnotations>
      </eStructuralFeatures>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="CompositeVariationPoint" eSuperTypes="#//cvl/VariationPoint">
      <eStructuralFeatures xsi:type="ecore:EReference" name="bindingCVSpec" ordered="false"
          lowerBound="1" eType="#//cvl/CVSpec">
        <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
          <details key="documentation" value="&lt;p>&lt;/p>"/>
        </eAnnotations>
      </eStructuralFeatures>
      <eStructuralFeatures xsi:type="ecore:EReference" name="children" upperBound="-1"
          eType="#//cvl/VariationPoint" containment="true"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="CVSpec" eSuperTypes="#//cvl/VSpec">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="&lt;p>A CVspec (Composite VSpec) is a kind of VSpec indicating that a base model element has inner variability as indicated by the extension of the CVSpec, which is a set of VSpecs.&lt;/p>"/>
      </eAnnotations>
      <eStructuralFeatures xsi:type="ecore:EReference" name="extension" ordered="false"
          lowerBound="1" eType="#//cvl/VInterface">
        <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
          <details key="documentation" value="&lt;p>The VInterface  whose members need to be resolved in order to resolve the CVSpec.&lt;/p>"/>
        </eAnnotations>
      </eStructuralFeatures>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="VConfiguration" eSuperTypes="#//cvl/VSpecResolution #//cvl/VPackageable">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="&lt;p>A Vconfiguration is a collection of variability resolutions made against a given configurable, i.e. a configurable unit or a configurable unit usage. The resolutions resolve VSpecs of the configurable's variability type (in case of a CU usage they resolve VSpecs of the variability type of the CU typing the usage).&lt;/p>&lt;p>&lt;br>A configuration C1 may have a preceding configuration C2. This indicates that C1 is meant to be applied after C2 has been applied, as part of a staged&lt;br>A configuration meant to be applied before this one as part of a staged materialization process.&lt;/p>&lt;p>&lt;/p>&lt;p>####CVLSemanticStart####&lt;/p>&lt;p>Invariant : The resolutions in a configuration resolve only VSpecs of its VInterface&lt;/p>&lt;p>OCL :&lt;/p>&lt;p>-- VConfiguration&lt;/p>&lt;p>-- The resolutions in a configuration resolve only VSpecs of its VInterface&lt;/p>&lt;p>def : isContained ( in vps : VSpec ) : Boolean = &lt;/p>&lt;p>                        self.resolvedVIRef.vInterface.vSpec-&amp;gt;exists(v | v = vps &lt;/p>&lt;p>                        or &lt;/p>&lt;p>                        (  if   not (v.childVSpec-&amp;gt;isEmpty())&lt;/p>&lt;p>                                        then&lt;/p>&lt;p>                                                v.childVSpec-&amp;gt;exists (child | isContained (child) = true)&lt;/p>&lt;p>                                        endif&lt;/p>&lt;p>                                 )&lt;/p>&lt;p>                        )&lt;/p>&lt;p>context VConfiguration&lt;/p>&lt;p>inv resolve_only_vspec_in_VInterface :&lt;/p>&lt;p>        self.vSpecResolution-&amp;gt;forAll(vspecRes | isContained(vspecRes.resolvedVSpec))&lt;/p>&lt;p>####CVLSemanticEnd####&lt;/p>"/>
      </eAnnotations>
      <eStructuralFeatures xsi:type="ecore:EReference" name="member" ordered="false"
          upperBound="-1" eType="#//cvl/VSpecResolution" containment="true"/>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="isPartial" ordered="false"
          lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EBoolean"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="super" ordered="false"
          eType="#//cvl/VConfiguration"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="resolvedVIRef" ordered="false"
          lowerBound="1" eType="#//cvl/CVSpec"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="VSpec2VSpecMapping">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="&lt;p>A VSpec2VSpecMapping specifies how to derive resolutions for certain VSpecs from resolutions of others via constraints.&lt;/p>"/>
      </eAnnotations>
      <eStructuralFeatures xsi:type="ecore:EReference" name="derivingConstraint" ordered="false"
          upperBound="-1" eType="#//cvl/OpaqueConstraint" containment="true"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="OpaqueConstraint" eSuperTypes="#//cvl/Constraint">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="&lt;p>A Constraint imposes additional restrictions that cannot be expressed in the base language. Each constraint has associated a VSpec context. It allows expressing universal quantification without explicit quantification phrases such as ''for all elements belonging to...'. Constraints written in a context are applied to each named VSpec that is available in this context.&lt;/p>&lt;p>The full constraint language (with classifiers) has set semantics for all non-propositional expressions (VSpecs, Integers, etc.). The small language (without classifiers) relies mostly on propositional formulas. A Constraint contains GeneralExpressions, which are always expected to evaluate to a boolean value. In case of set semantics GeneralExpressions are always LogicalExps, while in the small language they are LogicalExps or VSpecReferences. In the small language VSpecReferences have propositional semantics and are treated as Boolean choices.&lt;/p>&lt;p>####CVLSemanticStart####&lt;/p>&lt;p>&lt;b>&lt;/b>Invariant :&lt;b>&lt;/b> Each constraint must have a VSpec context&lt;/p>&lt;p>&lt;b>&lt;/b>OCL :&lt;b>&lt;/b>&lt;/p>&lt;p>-- Constraint&lt;/p>&lt;p>-- Each Constraint must have a VSpec context&lt;/p>&lt;p>context Constraint :&lt;/p>&lt;p>inv hasAVSpecContext :&lt;/p>&lt;p>not (self._context == (null))&lt;/p>&lt;p>####CVLSemanticEnd####&lt;/p>&lt;p>&lt;/p>"/>
      </eAnnotations>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="constraint" ordered="false"
          lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EString"/>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="constraintLanguage" ordered="false"
          lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EString"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="LinkExistence" eSuperTypes="#//cvl/Existence">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="&lt;p>LinkExistence is a kind of variation point which indicates that a link of the base model may or may not exist in the materialized model. The link is identified via a link handle.&lt;br>&lt;br>To be acted on, a LinkExistence variation point must be bound to a choice deciding whether or not the link will be present in the materialized model. It may not be bound to a variable or to a classifier.&lt;/p>&lt;p>####CVLSemanticStart####&lt;/p>&lt;p>Invariant : A LinkExistence must be bound to a Choice, not to a variable or to a classifier&lt;/p>&lt;p>OCL :&lt;/p>&lt;p>-- LinkExistence&lt;/p>&lt;p>-- A LinkExistence must be bound to a Choice, not to a variable or to a classifier&lt;/p>&lt;p>context LinkExistence :&lt;/p>&lt;p>inv linkExistence_must_bound_to_choice :&lt;/p>&lt;p>(self.bindingVspec-&amp;gt;exists( vspec | vspec.oclIsTypeOf(Choice)))&lt;/p>&lt;p>and (not (self.bindingVspec-&amp;gt;exists( vspec | vspec.oclIsTypeOf(Variable))))&lt;/p>&lt;p>and (not (self.bindingVspec-&amp;gt;exists( vspec | vspec.oclIsTypeOf(VClassifier))))&lt;/p>&lt;p>&lt;/p>&lt;p>Dynamic semantics&lt;/p>&lt;p>Pre and post condition&lt;/p>&lt;p>Pre-condition : &lt;/p>&lt;p>None&lt;/p>&lt;p>Post-condition: &lt;/p>&lt;p>After a LinkExistence has been executed, the optionalLink must be in the resolved model otherwise it cannot be in the resolved model.&lt;/p>&lt;p>OCL :&lt;/p>&lt;p>-- LinkExistence&lt;/p>&lt;p>context LinkExistence::eval(ctx : CVLExecutionContext)&lt;/p>&lt;p>pre : &lt;/p>&lt;p>post: &lt;/p>&lt;p>ctx.selectedVSpecs-&amp;gt;includes((self.bindingVspec-&amp;gt;asOrderedSet()-&amp;gt;first())) implies ctx.baseLinks-&amp;gt;includes(self.optionalLink) and&lt;/p>&lt;p>ctx.unselectedVSpecs-&amp;gt;includes(self.bindingVspec-&amp;gt;asOrderedSet()-&amp;gt;first()) implies not ctx.baseLinks-&amp;gt;includes(self.optionalLink)&lt;/p>&lt;p>####CVLSemanticEnd####&lt;/p>"/>
      </eAnnotations>
      <eStructuralFeatures xsi:type="ecore:EReference" name="optionalLink" ordered="false"
          lowerBound="1" eType="#//cvl/LinkHandle" containment="true">
        <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
          <details key="documentation" value="The link handle identifying the base model link whose existence is in question"/>
        </eAnnotations>
      </eStructuralFeatures>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="OpaqueVariationPoint" eSuperTypes="#//cvl/ChoiceVariationPoint">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="&lt;p>An OpaqueVariationPoint is an executable, domain-specific variation point whose semantics is not defined by CVL. It is the responsibility of the specfic domain to execute this kind of variation point.&lt;br>&lt;br>If bound to a choice then an OpaqueVariation point will be executed upon a positive decision. If bound to a VClassifier then it will be executed once for each instance created from it. If bound to a variable then it will be executed when a value is assigned to it, also providing the value as parameter for the execution.&lt;br>&lt;/p>&lt;p>####CVLSemanticStart####&lt;/p>&lt;p>&lt;/p>&lt;p>Dynamic semantics&lt;/p>&lt;p>The OpaqueVariationPoint allows user to make use of variations that are not directly defined by CVL. So, its semantics is not detailed here, and we do not have pre and post conditions&lt;/p>&lt;p>Pre and post condition&lt;/p>&lt;p>Pre-condition : &lt;/p>&lt;p>None&lt;/p>&lt;p>Post-condition: &lt;/p>&lt;p>None&lt;/p>&lt;p>OCL :&lt;/p>&lt;p>-- OpaqueVariationPoint&lt;/p>&lt;p>context OpaqueVariationPoint::eval(ctx : CVLExecutionContext)&lt;/p>&lt;p>pre : true&lt;/p>&lt;p>post : true&lt;/p>&lt;p>####CVLSemanticEnd####&lt;/p>"/>
      </eAnnotations>
      <eStructuralFeatures xsi:type="ecore:EReference" name="placeHolder" ordered="false"
          lowerBound="1" eType="#//cvl/BaseModelHandle" containment="true"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="sourceObject" ordered="false"
          lowerBound="1" upperBound="-1" eType="#//cvl/ObjectHandle" containment="true"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="type" ordered="false"
          lowerBound="1" eType="#//cvl/OVPType"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="OVPType" eSuperTypes="#//cvl/VPackageable">
      <eStructuralFeatures xsi:type="ecore:EReference" name="spec" ordered="false"
          lowerBound="1" eType="#//cvl/OVPSemanticSpec" containment="true"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="OVPSemanticSpec">
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="modelTransformation"
          ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EString"/>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="transfromationLanguage"
          ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EString"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="ObjectSpecification" eSuperTypes="#//cvl/ValueSpecification">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="An ObjectSpecification specifies a value which is an object of the base mode through an object handle."/>
      </eAnnotations>
      <eStructuralFeatures xsi:type="ecore:EReference" name="object" ordered="false"
          lowerBound="1" eType="#//cvl/ObjectHandle">
        <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
          <details key="documentation" value="The object specified."/>
        </eAnnotations>
      </eStructuralFeatures>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="ReplacementFragmentSpecification"
        eSuperTypes="#//cvl/ValueSpecification">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="A value of ReplacementFragmentType"/>
      </eAnnotations>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="VPackage" eSuperTypes="#//cvl/VPackageable">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="A VPacakge (Variability Package) is the packaging mechanism of CVL."/>
      </eAnnotations>
      <eStructuralFeatures xsi:type="ecore:EReference" name="packageElement" ordered="false"
          upperBound="-1" eType="#//cvl/VPackageable" containment="true"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="ToBinding" eSuperTypes="#//cvl/BoundaryElementBinding">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="&lt;p>ToBinding defines a binding between boundary elements of kind ToPlacement/ToReplacement. The ToPlacement boundary element&lt;br>has to be bound to the ToReplacement.&lt;/p>&lt;p>&lt;/p>&lt;p>####CVLSemanticStart####&lt;/p>&lt;p>Invariant&lt;/p>&lt;p>Invariant : The ToPlacement boundary element must be bound to the ToReplacement element&lt;/p>&lt;p>OCL :&lt;/p>&lt;p>-- The ToPlacement boundary element must be bound to the ToReplacement element&lt;/p>&lt;p>context ToBinding :&lt;/p>&lt;p>inv mustBeBoundToTheToReplacement :&lt;/p>&lt;p>self.toPlacement.toReplacement = self.toReplacement&lt;/p>&lt;p>Dynamic semantics&lt;/p>&lt;p>Pre and post condition&lt;/p>&lt;p>Pre-condition : &lt;/p>&lt;p>None&lt;/p>&lt;p>Post-condition: &lt;/p>&lt;p>After a FragmentSubstitution has been executed (and as a consequence a ToBinding), the elements that referenced before the placement inside model elements reference now the replacement inside model elements.&lt;/p>&lt;p>OCL :&lt;/p>&lt;p>-- ToBinding&lt;/p>&lt;p>-- (FragmentSubstitution : the placement and replacement boundary elements are connected by bindings)&lt;/p>&lt;p>-- toPlacement.outsideBoundaryElement.propertyName[] = toReplacement.insideBoundaryElement[]&lt;/p>&lt;p>context ToBinding::eval(ctx : CVLExecutionContext)&lt;/p>&lt;p>pre :&lt;/p>&lt;p>post : self.toPlacement.outsideBoundaryElement.getPropertyValue(self.toPlacement.propertyName)-&amp;gt;forAll( val | val.oclIsTypeOf(ObjectHandle) and  self.toReplacement.insideBoundaryElement-&amp;gt;includes(val.oclAsType(ObjectHandle)))&lt;/p>&lt;p>&lt;/p>&lt;p>####CVLSemanticEnd####&lt;/p>"/>
      </eAnnotations>
      <eStructuralFeatures xsi:type="ecore:EReference" name="toPlacement" ordered="false"
          lowerBound="1" eType="#//cvl/ToPlacement">
        <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
          <details key="documentation" value="Specifies the ToPlacement boundary element that is part of the binding."/>
        </eAnnotations>
      </eStructuralFeatures>
      <eStructuralFeatures xsi:type="ecore:EReference" name="toReplacement" ordered="false"
          lowerBound="1" eType="#//cvl/ToReplacement">
        <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
          <details key="documentation" value="Specifies the ToReplacement boundary element that is part of the binding."/>
        </eAnnotations>
      </eStructuralFeatures>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="ToPlacement" eSuperTypes="#//cvl/PlacementBoundaryElement">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="&lt;p>ToPlacement is the kind of boundary element that defines the boundary between the owning placement fragment and the rest of the base model. The insideBoundaryElements denote the ModelElements of owning fragment that are referred to by outside model elements. The outsideBoundaryElement together with the propertyName denotes the attributes of model elements on the outside of the placement fragment that refer to the inside boundary model elements.&lt;/p>&lt;p>Constraints:&lt;/p>&lt;p>insideBoundaryElement = outsideRef.insideBoundaryElement outsideBoundaryElement != null xor outsideRef != null&lt;/p>&lt;p>####CVLSemanticStart####&lt;/p>&lt;p>Invariant :&lt;/p>&lt;p > Constraint : &lt;/p>&lt;p >1) self.outsideBoudaryElement &amp;lt;&amp;gt; null xor outsideRef != null&lt;/p>&lt;p >2) All outsideBoundaryElement point on insideBoundaryElement&lt;/p>&lt;p>OCL :&lt;/p>&lt;p>-- ToPlacement&lt;/p>&lt;p>-- The outsideBoundaryElement together with the propertyName denotes the attributes of model elements outside of the placement fragment that refer to the inside boundary model elements&lt;/p>&lt;p>-- Constraint : &lt;/p>&lt;p>-- 1) self.outsideBoudaryElement &amp;lt;&amp;gt; null xor outsideRef != null&lt;/p>&lt;p>--  2) All outsideBoundaryElement point on insideBoundaryElement&lt;/p>&lt;p>context ToPlacement :&lt;/p>&lt;p> inv insideBoundaryElements_outsideRef :&lt;/p>&lt;p>                -- 1) self.outsideBoudaryElement &amp;lt;&amp;gt; null&lt;/p>&lt;p>                (not self.outsideBoundaryElement-&amp;gt;isEmpty()&lt;/p>&lt;p>        xor self.outsideBoundaryElement.getPropertyValue(self.propertyName) &amp;lt;&amp;gt; null)&lt;/p>&lt;p>        and&lt;/p>&lt;p>                --  2) All outsideBoundaryElement point on insideBoundaryElement&lt;/p>&lt;p>                self.outsideBoundaryElement.getPropertyValue(self.propertyName)-&amp;gt;forAll( val | self.insideBoundaryElement-&amp;gt;includes(val.oclAsType(ObjectHandle) ))&lt;/p>&lt;p>####CVLSemanticEnd####&lt;/p>"/>
      </eAnnotations>
      <eStructuralFeatures xsi:type="ecore:EReference" name="toReplacement" ordered="false"
          eType="#//cvl/ToReplacement" eOpposite="#//cvl/ToReplacement/toPlacement">
        <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
          <details key="documentation" value="Reference to a ToReplacement in a containing replacement fragment."/>
        </eAnnotations>
      </eStructuralFeatures>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="propertyName" ordered="false"
          lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EString">
        <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
          <details key="documentation" value="Name of the attribute to be changed."/>
        </eAnnotations>
      </eStructuralFeatures>
      <eStructuralFeatures xsi:type="ecore:EReference" name="insideBoundaryElement"
          ordered="false" upperBound="-1" eType="#//cvl/ObjectHandle" containment="true">
        <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
          <details key="documentation" value="Model elements that are referred to by outside model elements. Used to distinguish miltiplicity references."/>
        </eAnnotations>
      </eStructuralFeatures>
      <eStructuralFeatures xsi:type="ecore:EReference" name="outsideBoundaryElement"
          ordered="false" eType="#//cvl/ObjectHandle" containment="true">
        <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
          <details key="documentation" value="Outside model elements that refer model elements inside the fragment."/>
        </eAnnotations>
      </eStructuralFeatures>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="ToReplacement" eSuperTypes="#//cvl/ReplacementBoundaryElement">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="&lt;p>&#xD;&#xA;    ToReplacement is the kind of boundary element that defines the inwards boundary of the owning replacement fragment. The&#xD;&#xA;    insideBoundaryElement defines the starting points for the traversal to isolate the model elements that as part of a&#xD;&#xA;    fragment substitution will be copied into the placement fragment.&#xD;&#xA;&lt;/p>"/>
      </eAnnotations>
      <eStructuralFeatures xsi:type="ecore:EReference" name="insideBoundaryElement"
          ordered="false" upperBound="-1" eType="#//cvl/ObjectHandle" containment="true">
        <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
          <details key="documentation" value="Model elements that are referred to by outside model elements."/>
        </eAnnotations>
      </eStructuralFeatures>
      <eStructuralFeatures xsi:type="ecore:EReference" name="toPlacement" ordered="false"
          eType="#//cvl/ToPlacement" containment="true" eOpposite="#//cvl/ToPlacement/toReplacement">
        <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
          <details key="documentation" value="Reference to a ToPlacement contained by the replacement fragment."/>
        </eAnnotations>
      </eStructuralFeatures>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="FromBinding" eSuperTypes="#//cvl/BoundaryElementBinding">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="&lt;p>FromBinding defines a binding between boundary elements of kind FromPlacement/FromReplacement. The FromPlacement boundary&lt;br>element that has to be bound to the FromPlacement.&lt;/p>&lt;p>####CVLSemanticStart####&lt;/p>&lt;p>Invariant&lt;/p>&lt;p>Invariant : The FromPlacement boundary element must be bound to the FromReplacement element.&lt;/p>&lt;p>OCL :&lt;/p>&lt;p>&lt;/p>&lt;p>-- The FromPlacement boundary element must be bound to the FromReplacement element&lt;/p>&lt;p>context FromBinding :&lt;/p>&lt;p>inv mustBeBoundToTheReplacement :&lt;/p>&lt;p>self.fromPlacement.fromReplacement = self.fromReplacement&lt;/p>&lt;p>Dynamic semantics&lt;/p>&lt;p>Pre and post condition&lt;/p>&lt;p>Pre-condition : &lt;/p>&lt;p>None&lt;/p>&lt;p>Post-condition: &lt;/p>&lt;p>After a FragmentSubstitution has been executed (and as a consequence a FromBinding), the elements inside the replacement element references the element outside the placement elements. These outside elements referenced before the placement elements.&lt;/p>&lt;p>OCL :&lt;/p>&lt;p>-- FromBinding&lt;/p>&lt;p>-- (FragmentSubstitution : the placement and replacement boundary elements are connected by bindings)&lt;/p>&lt;p>-- fromReplacement.insideBoundaryElement.propertyName[] = fromPlacement.outsideBoundaryElement[]&lt;/p>&lt;p>context FromBinding::eval(ctx : CVLExecutionContext)&lt;/p>&lt;p>pre :&lt;/p>&lt;p>post : self.fromReplacement.insideBoundaryElement.getPropertyValue(self.fromReplacement.propertyName)-&amp;gt;forAll( val | val.oclIsTypeOf(ObjectHandle) and  self.fromPlacement.outsideBoundaryElement-&amp;gt;includes(val.oclAsType(ObjectHandle)))&lt;/p>&lt;p>####CVLSemanticEnd####&lt;/p>"/>
      </eAnnotations>
      <eStructuralFeatures xsi:type="ecore:EReference" name="fromPlacement" ordered="false"
          lowerBound="1" eType="#//cvl/FromPlacement">
        <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
          <details key="documentation" value="Specifies the FromPlacement boundary element that is part of the binding."/>
        </eAnnotations>
      </eStructuralFeatures>
      <eStructuralFeatures xsi:type="ecore:EReference" name="fromReplacement" ordered="false"
          lowerBound="1" eType="#//cvl/FromReplacement">
        <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
          <details key="documentation" value="Specifies the FromReplacement boundary element that is part of the binding."/>
        </eAnnotations>
      </eStructuralFeatures>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="FromPlacement" eSuperTypes="#//cvl/PlacementBoundaryElement">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="FromPlacement is the kind of boundary element that defines the outwards boundary of the owning placement fragment. The&#xD;&#xA;outsideBoundaryElement refers to the model elements on the outside of the placement fragment. In a fragment substitution&#xD;&#xA;these have to be referred by model elements within the replacement fragment."/>
      </eAnnotations>
      <eStructuralFeatures xsi:type="ecore:EReference" name="fromReplacement" ordered="false"
          eType="#//cvl/FromReplacement" eOpposite="#//cvl/FromReplacement/fromPlacement">
        <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
          <details key="documentation" value="Reference to a FromReplacement in a containing replacement fragment."/>
        </eAnnotations>
      </eStructuralFeatures>
      <eStructuralFeatures xsi:type="ecore:EReference" name="outsideBoundaryElement"
          ordered="false" upperBound="-1" eType="#//cvl/ObjectHandle" containment="true">
        <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
          <details key="documentation" value="Outside Model Element that are referred by the model elements inside the placement fragment."/>
        </eAnnotations>
      </eStructuralFeatures>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="FromReplacement" eSuperTypes="#//cvl/ReplacementBoundaryElement">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="FromReplacement is the kind of boundary element that defines the outwards boundary of the owning replacement fragment.&#xD;&#xA;propertyName is the name of the reference attribute of inside boundary model element that will be changed as part of a&#xD;&#xA;fragment substitution. The insideBoundaryElements refer to the base model elements that will have their reference&#xD;&#xA;attributes updated as part of a fragment substitution. The outsideBoundaryElement refers to the model elements on the&#xD;&#xA;outside of the replacement fragment. In a fragment substitution these references are used to define the extent of the&#xD;&#xA;replacement fragment."/>
      </eAnnotations>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="propertyName" ordered="false"
          lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EString">
        <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
          <details key="documentation" value="Name of the attribute to be changed."/>
        </eAnnotations>
      </eStructuralFeatures>
      <eStructuralFeatures xsi:type="ecore:EReference" name="insideBoundaryElement"
          ordered="false" eType="#//cvl/ObjectHandle" containment="true">
        <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
          <details key="documentation" value="Inside model elements that refer outside model elements."/>
        </eAnnotations>
      </eStructuralFeatures>
      <eStructuralFeatures xsi:type="ecore:EReference" name="outsideBoundaryElement"
          ordered="false" upperBound="-1" eType="#//cvl/ObjectHandle" containment="true">
        <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
          <details key="documentation" value="Outside&amp;nbsp;model&amp;nbsp;elements&amp;nbsp;that&amp;nbsp;are&amp;nbsp;referred&amp;nbsp;by&amp;nbsp;model&amp;nbsp;elements&amp;nbsp;inside&amp;nbsp;the&amp;nbsp;fragment.&amp;nbsp;Used&amp;nbsp;to&amp;nbsp;distinguish&amp;nbsp;multiplicity&lt;br />&#xD;&#xA;references."/>
        </eAnnotations>
      </eStructuralFeatures>
      <eStructuralFeatures xsi:type="ecore:EReference" name="fromPlacement" ordered="false"
          eType="#//cvl/FromPlacement" eOpposite="#//cvl/FromPlacement/fromReplacement">
        <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
          <details key="documentation" value="Reference to a FromPlacement contained by the replacement fragment."/>
        </eAnnotations>
      </eStructuralFeatures>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="VSpecRef" eSuperTypes="#//cvl/OCLExpression">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="A&amp;nbsp;VSpecReference&amp;nbsp;points&amp;nbsp;to&amp;nbsp;a&amp;nbsp;VSpec&amp;nbsp;element&amp;nbsp;(choice,&amp;nbsp;variable,&amp;nbsp;classifier).&amp;nbsp;In&amp;nbsp;set&amp;nbsp;semantics,&amp;nbsp;VSpecReference&amp;nbsp;is&amp;nbsp;always&amp;nbsp;treated&amp;nbsp;as&amp;nbsp;a&amp;nbsp;set&amp;nbsp;expression;&amp;nbsp;choices&amp;nbsp;and&amp;nbsp;variables&amp;nbsp;are&amp;nbsp;modeled&amp;nbsp;as&amp;nbsp;singletons&amp;nbsp;or&amp;nbsp;empty&amp;nbsp;sets.&amp;nbsp;In&amp;nbsp;the&amp;nbsp;small&amp;nbsp;language&amp;nbsp;there&amp;nbsp;is&amp;nbsp;no&amp;nbsp;set&amp;nbsp;semantics;&amp;nbsp;VSpecReference&amp;nbsp;to&amp;nbsp;a&amp;nbsp;choice&amp;nbsp;is&amp;nbsp;then&amp;nbsp;treated&amp;nbsp;as&amp;nbsp;a&amp;nbsp;Boolean&amp;nbsp;(evaluates&amp;nbsp;to&amp;nbsp;true&amp;nbsp;or&amp;nbsp;false),&amp;nbsp;and&amp;nbsp;a&amp;nbsp;variable&amp;nbsp;reference&amp;nbsp;resolves&amp;nbsp;to&amp;nbsp;the&amp;nbsp;value&amp;nbsp;of&amp;nbsp;the&amp;nbsp;variable."/>
      </eAnnotations>
      <eStructuralFeatures xsi:type="ecore:EReference" name="vSpec" ordered="false"
          lowerBound="1" eType="#//cvl/VSpec"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="OCLExpression"/>
    <eClassifiers xsi:type="ecore:EClass" name="VSpecToConfigMapping">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="&lt;p>A VSpec2VSpecMapping specifies how to derive resolutions for certain VSpecs from resolutions of others by specifying that the fulfillment of a certain constraint implies an entire configuration.&lt;/p>"/>
      </eAnnotations>
      <eStructuralFeatures xsi:type="ecore:EReference" name="thenConfiguration" ordered="false"
          eType="#//cvl/VConfiguration"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="ifConstraint" ordered="false"
          lowerBound="1" eType="#//cvl/OpaqueConstraint" containment="true"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="ParametricVariationPoint" abstract="true"
        eSuperTypes="#//cvl/VariationPoint">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="&lt;p>A parametric variation point is a variation point which inserts a value into the base model. The value to be inserted is a parameter of the variation point. A parametric variation point must be bound to a VSpec of kind variable, which represents the variation point's parameter.&lt;/p>"/>
      </eAnnotations>
      <eStructuralFeatures xsi:type="ecore:EReference" name="bindingVariable" ordered="false"
          lowerBound="1" eType="#//cvl/Variable"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="SlotValueExistence" eSuperTypes="#//cvl/Existence">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="&lt;p>SlotValueExistence is a kind of choice variation point which indicates that a value in a slot of some object of the base model may or may not exist in the materialized model. The object is identified via an object handle.&lt;br>&lt;br>To be acted on, an SlotValueExistence variation point must be bound to a choice deciding whether or not the object will be present in the materialized model. It may not be bound to a variable or to a classifier.&lt;/p>&lt;p>####CVLSemanticStart####&lt;/p>&lt;p>&lt;/p>&lt;p>Dynamic semantics&lt;/p>&lt;p>Pre and post condition&lt;/p>&lt;p>Pre-condition : &lt;/p>&lt;p>Before the execution of a SlotValueExistence, the slotOwner element must exist in the base model.&lt;/p>&lt;p>Post-condition: &lt;/p>&lt;blockquote>&lt;p>After a SlotValueExsitence has been executed, the MoF property with the name such as in the slotIdentifier is in the ObjectHandle otherwise it cannot be found in the ObjectHandle.&lt;/p>&lt;/blockquote>&lt;p>OCL :&lt;/p>&lt;p>-- SlotValueExistence &lt;/p>&lt;p>context SlotValueExistence::eval(ctx : CVLExecutionContext)&lt;/p>&lt;p>pre : ctx.resolvedModelElements-&amp;gt;includes(self.slotOwner)&lt;/p>&lt;p>post : &lt;/p>&lt;p>ctx.selectedVSpecs-&amp;gt;includes(self.bindingVspec-&amp;gt;asOrderedSet()-&amp;gt;first()) implies self.slotOwner-&amp;gt;asOrderedSet()-&amp;gt;first().getPropertyByName(self.slotIdentifier) &amp;lt;&amp;gt; null&lt;/p>&lt;p>and&lt;/p>&lt;p>ctx.unselectedVSpecs-&amp;gt;includes(self.bindingVspec-&amp;gt;asOrderedSet()-&amp;gt;first()) implies (self.slotOwner-&amp;gt;asOrderedSet()-&amp;gt;first().getPropertyByName(self.slotIdentifier)) == (null)&lt;/p>&lt;p>####CVLSemanticEnd####&lt;/p>"/>
      </eAnnotations>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="slotIdentifier" ordered="false"
          lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EString"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="slotOwner" ordered="false"
          lowerBound="1" eType="#//cvl/ObjectHandle" containment="true"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="ParametricLinkAssignment" eSuperTypes="#//cvl/ParametricVariationPoint">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="&lt;p>A ParametricLinkAssignmet is a parametric variation point which specifies that an object arriving as parameter, called the replacement, will be substituted for an object of the base model as the end of a particular link in the base model.&lt;br>&lt;br>The link-end is identified via a link handle pointing to the base model plus a string representing a MOF property owned by the association of which the link is an instance.&lt;br>The variation point must be bound to a variable which provides the replacement. It may not be bound to a choice or classifier.&lt;/p>&lt;p>####CVLSemanticStart####&lt;/p>&lt;p>&lt;/p>&lt;p>Dynamic semantics&lt;/p>&lt;p>Pre and post condition&lt;/p>&lt;p>Pre-condition :&lt;/p>&lt;p>Before the execution of a ParametricLinkAssignment, the link link must exist in the base model and a end corresponding to the given linkEndIdentifier exists in the ObjectHandle.&lt;/p>&lt;p>Post-condition:&lt;/p>&lt;p>After a ParametricLinkAssignment has been executed, the object which arrives in the variable is at the end of the link link.&lt;/p>&lt;p>OCL :&lt;/p>&lt;p>-- ParametricLinkAssignment&lt;/p>&lt;p>-- A end corresponding to the given linkEndIdentifier exists in the ObjectHandle&lt;/p>&lt;p>context ParametricLinkAssignment::eval(ctx : CVLExecutionContext)&lt;/p>&lt;p>pre : ctx.baseLinks-&amp;gt;includes(self.link)&lt;/p>&lt;p>and if self.getPropertyValue(self.linkEndIdentifier) &amp;lt;&amp;gt; null&lt;/p>&lt;p>then&lt;/p>&lt;p>self.getPropertyValue(self.linkEndIdentifier)-&amp;gt;forAll( val | ctx.resolvedModelElements-&amp;gt;includes(val.oclAsType(ObjectHandle)))&lt;/p>&lt;p>else&lt;/p>&lt;p>false&lt;/p>&lt;p>endif&lt;/p>&lt;p>post: self.link.getEnd()-&amp;gt;includes(&lt;/p>&lt;p>VariableValueAssignment.allInstances()-&amp;gt;select (varValueAssign | (self.bindingVspec&lt;/p>&lt;p>-&amp;gt;includes(varValueAssign.resolvedVariable)))-&amp;gt;asOrderedSet()-&amp;gt;first().value )&lt;/p>&lt;p>####CVLSemanticEnd####&lt;/p>"/>
      </eAnnotations>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="linkEndIdentifier" ordered="false"
          lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EString"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="link" ordered="false"
          lowerBound="1" eType="#//cvl/LinkHandle" containment="true"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="ParametricObjectSubstitution" eSuperTypes="#//cvl/ParametricVariationPoint">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="&lt;p>A ParametricObjectSubstitution is a parametric variation point which specifies that an object arriving as parameter, called the replacement, will be substituted for an object of the base model, called the placement.&lt;br>&lt;br>The placement object is identified via an object handle identifying a base model object. The variation point must be bound to a variable which provides the replacement.&lt;br>&lt;br>&lt;br>An ObjectSubstitution may not be bound to a choice or VClassifier.&lt;/p>&lt;p>####CVLSemanticStart####&lt;/p>&lt;p>Dynamic semantics&lt;/p>&lt;p>Pre and post condition&lt;/p>&lt;p>Pre-condition :&lt;/p>&lt;p>Before the execution of a ParametricObjectSubstitution, the placement object must exist in the base model and the replacement object is in the variable.&lt;/p>&lt;p>Post-condition:&lt;/p>&lt;p>After a ParametricObjectSubstution has been executed, the replacement object must exist in the resolved model whereas the placement object cannot be found in the resolved model.&lt;/p>&lt;p>OCL :&lt;/p>&lt;p>-- ParametricObjectSubstitution&lt;/p>&lt;p>context ParametricObjectSubstitution::eval(ctx : CVLExecutionContext) &lt;/p>&lt;p>        pre: &lt;/p>&lt;p>        ctx.resolvedModelElements-&amp;gt;includes( self.placementObject) &lt;/p>&lt;p>        and (VariableValueAssignment.allInstances()-&amp;gt;select (varValueAssign |  (self.bindingVspec&lt;/p>&lt;p>-&amp;gt;includes(varValueAssign.resolvedVariable)))-&amp;gt;asOrderedSet()-&amp;gt;first().value) &amp;lt;&amp;gt; null&lt;/p>&lt;p> post: &lt;/p>&lt;p>        ctx.resolvedModelElements-&amp;gt;includes( (VariableValueAssignment.allInstances()-&amp;gt;select (varValueAssign |  (self.bindingVspec&lt;/p>&lt;p>-&amp;gt;includes(varValueAssign.resolvedVariable)))-&amp;gt;asOrderedSet()-&amp;gt;first().value).oclAsType(ObjectSpecification).object) &lt;/p>&lt;p>        and not ctx.resolvedModelElements-&amp;gt;includes( self.placementObject)&lt;/p>&lt;p>####CVLSemanticEnd####&lt;/p>"/>
      </eAnnotations>
      <eStructuralFeatures xsi:type="ecore:EReference" name="placementObject" ordered="false"
          lowerBound="1" eType="#//cvl/ObjectHandle" containment="true"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="ParametricSlotAssignmet" eSuperTypes="#//cvl/ParametricVariationPoint">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="&lt;p>A parametric slot assignment is a parametric variation point which specifies that a value arriving as parameter will be assigned to a particular slot in a particular object in the base model. The object is identified via an object handle pointing to the base model, and the slot is identified via a string representing a MOF property owned by the class of which the object is an instance. The variation point must be bound to a variable providing the value to be assigned.&lt;br>&lt;br>A parametric slot assignment may not be bound to a VClassifer or choice.&lt;/p>&lt;p>&lt;/p>&lt;p>####CVLSemanticStart####&lt;/p>&lt;p>Invariant&lt;/p>&lt;p>Invariant : The slotIdentifier must correspond to a property name of the associated ObjectHandle&lt;/p>&lt;p>OCL :&lt;/p>&lt;p>-- ParametricSlotAssignment&lt;/p>&lt;p>-- The slotIdentifier must correspond to a property name of the associated ObjectHandle&lt;/p>&lt;p>context ParametricSlotAssignmet :&lt;/p>&lt;p>inv slotIdentifierExists :&lt;/p>&lt;p>self.slotOwner.getPropertyByName(self.slotIdentifier) &amp;lt;&amp;gt; null&lt;/p>&lt;p>Dynamic semantics&lt;/p>&lt;p>Pre and post condition&lt;/p>&lt;p>Pre-condition :&lt;/p>&lt;p>Before the execution of a ParametricSlotAssignment, the ObjectHandle slotOwner must exist in the base model.&lt;/p>&lt;p>Post-condition:&lt;/p>&lt;p>After a ParametricSlotAssignment has been executed, the slot identified by the slotIdentifier and contained in the ObjectHandle slotOwner is assigned with a given value.&lt;/p>&lt;p>OCL :&lt;/p>&lt;p>-- ParametricSlotAssignment&lt;/p>&lt;p>context ParametricSlotAssignmet::eval(ctx : CVLExecutionContext)&lt;/p>&lt;p>pre : ctx.resolvedModelElements-&amp;gt;includes(self.slotOwner)&lt;/p>&lt;p>post: self.slotOwner.getPropertyValue(self.slotIdentifier)-&amp;gt;asOrderedSet()-&amp;gt;first() == (VariableValueAssignment.allInstances()-&amp;gt;select (varValueAssign | (self.bindingVspec&lt;/p>&lt;p>-&amp;gt;includes(varValueAssign.resolvedVariable)))-&amp;gt;asOrderedSet()-&amp;gt;first().value)&lt;/p>&lt;p>####CVLSemanticEnd####&lt;/p>"/>
      </eAnnotations>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="slotIdentifier" ordered="false"
          lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EString"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="slotOwner" ordered="false"
          lowerBound="1" eType="#//cvl/ObjectHandle" containment="true"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="ChoiceDerivation" eSuperTypes="#//cvl/VSpecDerivation">
      <eStructuralFeatures xsi:type="ecore:EReference" name="derivingConstraint" ordered="false"
          lowerBound="1" eType="#//cvl/Constraint" containment="true"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="VariableDerivation" eSuperTypes="#//cvl/VSpecDerivation">
      <eStructuralFeatures xsi:type="ecore:EReference" name="derivingExpression" ordered="false"
          lowerBound="1" eType="#//cvl/OCLExpression" containment="true"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="CVSpecDerivation" eSuperTypes="#//cvl/VSpecDerivation">
      <eStructuralFeatures xsi:type="ecore:EReference" name="memberDerivation" ordered="false"
          upperBound="-1" eType="#//cvl/VSpecDerivation" containment="true"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="ConfigurableUnitUsage" eSuperTypes="#//cvl/CompositeVariationPoint">
      <eStructuralFeatures xsi:type="ecore:EReference" name="usedUnit" ordered="false"
          lowerBound="1" eType="#//cvl/ConfigurableUnit"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="usageReference" ordered="false"
          lowerBound="1" eType="#//cvl/LinkHandle" containment="true"/>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="linkEndIdentifier" ordered="false"
          lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EString"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="PrimitiveValueSpecification" eSuperTypes="#//cvl/ValueSpecification">
      <eStructuralFeatures xsi:type="ecore:EReference" name="expression" ordered="false"
          eType="#//cvl/OCLExpression" containment="true"/>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="value" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EString"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="OCLConstraint" eSuperTypes="#//cvl/Constraint">
      <eStructuralFeatures xsi:type="ecore:EReference" name="expression" ordered="false"
          lowerBound="1" upperBound="-1" eType="#//cvl/OCLExpression" containment="true"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="OperationCallExp" eSuperTypes="#//cvl/OCLExpression">
      <eStructuralFeatures xsi:type="ecore:EReference" name="argument" ordered="false"
          upperBound="-1" eType="#//cvl/OCLExpression" containment="true"/>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="operation" ordered="false"
          lowerBound="1" eType="#//cvl/Operation"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EEnum" name="Operation">
      <eLiterals name="logNot"/>
      <eLiterals name="logAnd" value="1"/>
      <eLiterals name="logOr" value="2"/>
      <eLiterals name="logImplies" value="3"/>
      <eLiterals name="logXor" value="4"/>
      <eLiterals name="logIff" value="5"/>
      <eLiterals name="arithPlus" value="6"/>
      <eLiterals name="arithMinus" value="7"/>
      <eLiterals name="arithNeg" value="8"/>
      <eLiterals name="arithMult" value="9"/>
      <eLiterals name="arithDev" value="10"/>
      <eLiterals name="strConc" value="11"/>
      <eLiterals name="eq" value="12"/>
      <eLiterals name="lte" value="13"/>
      <eLiterals name="gte" value="14"/>
      <eLiterals name="lt" value="15"/>
      <eLiterals name="gt" value="16"/>
      <eLiterals name="isDefined" value="17"/>
      <eLiterals name="isUndefined" value="18"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="BooleanLiteralExp" eSuperTypes="#//cvl/OCLExpression">
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="bool" ordered="false"
          lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EBoolean"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="StringLiteralExp" eSuperTypes="#//cvl/OCLExpression">
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="string" ordered="false"
          lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EString"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="NumericLiteralExp" eSuperTypes="#//cvl/OCLExpression"/>
    <eClassifiers xsi:type="ecore:EClass" name="IntegerLiteralExp" eSuperTypes="#//cvl/NumericLiteralExp">
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="integer" ordered="false"
          lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EInt"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="UnlimitedLiteralExp" eSuperTypes="#//cvl/NumericLiteralExp">
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="unlimited" ordered="false"
          lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EInt"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="RealLiteralExp" eSuperTypes="#//cvl/NumericLiteralExp">
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="real" ordered="false"
          lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EDouble"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="PatternIntegration" eSuperTypes="#//cvl/ChoiceVariationPoint #//cvl/RepeatableVariationPoint">
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="multi" ordered="false"
          lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EBoolean"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="substitutes" upperBound="-1"
          eType="#//cvl/ObjectSubstitution"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="PatternFusion" eSuperTypes="#//cvl/ChoiceVariationPoint #//cvl/RepeatableVariationPoint">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="&lt;p>Fragment Substitution substitutes a placement fragment of the base model with one or more replacement fragments of the base model.&lt;/p>&lt;p>Constraints:&lt;/p>&lt;p>The boundary elements define all references going in and out of the placement fragment. The boundary elements fully define all references going in and out of the replacement fragment.&lt;/p>&lt;p>Semantics:&lt;/p>&lt;p>1. Delete the model elements defined by the PlacementFragment. The placement model elements can be found through FragmentSubstitution.placement's placementBoundaryElements that are of class ToPlacement (using the model element references called insideBoundaryElement) and the transitive closure of all references from these, where the traversal is cut off at any reference that has the same value as any of FragmentSubstitution.placement's PlacementBoundardyElement that are of class FromPlacement (using the model element references called outsideBoundaryElement).&lt;/p>&lt;p>&lt;br>2. For the replacement fragments, copy its content onto the hole made by the deletion of the placement fragment. The placement and replacement boundary elements must correspond. The content model elements can be found through FragmentSubstitution. replacement's ReplacementBoundaryElement that are of type ToReplacement (using the model element references called insideBoundaryElement) and all model elements found through the transitive closure of all references from this set of model elements, where the traversal is cut off at any reference that has the same value as any of FragmentSubstitution.replacement's ReplacementBoundaryElement that are of type FromReplacement (using the model element references called outsideBoundaryElement).&lt;/p>&lt;p>If multi is true, then a number of copies of the replacement fragment will be copied onto the placement. The resolution model will define how many.&lt;/p>&lt;p>Any substitutions addressing placements inside the given replacement fragment will be performed on the copy of the replacement fragment which is the last one generated.&lt;/p>&lt;p>3. Binding boundary elements. The placement and replacement boundary elements are connected by bindings. The bindings are given by the BoundaryElementBindings:&lt;br>1. FromBinding: fromReplacement.insideBoundaryElement.propertyName[] = fromPlacement.outsideBoundaryElement[]&lt;br>2. ToBinding: toPlacement.outsideBoundaryElement.propertyName[] = toReplacement.insideBoundaryElement[]. This definition in fact also covers attributes that have multiplicity. Such attributes may be seen as arrays or collections, and repeated reference assignments to such attributes during variability transformation will mean adding a new individual reference to the identifier collection.&lt;/p>&lt;p>####CVLSemanticStart####&lt;/p>&lt;p>&lt;/p>&lt;p>Dynamic semantics&lt;/p>&lt;p>Pre and post condition&lt;/p>&lt;p>Pre-condition : &lt;/p>&lt;p>Before the execution of a Fragment Substitution, the placement fragment must exist in the base model.&lt;/p>&lt;p>Post-condition: &lt;/p>&lt;p>After a FragmentSubstitution has been executed, the placement elements cannot be found in the resolved model whereas the replacement elements are in the resolved model.&lt;/p>&lt;p>OCL :&lt;/p>&lt;p>context FragmentSubstitution::eval(ctx : CVLExecutionContext)&lt;/p>&lt;p>pre : &lt;/p>&lt;p>self.boundaryElementBinding-&amp;gt;forAll(boundaryElt |boundaryElt.oclIsTypeOf(ToBinding) implies boundaryElt.oclAsType(ToBinding).toPlacement.insideBoundaryElement-&amp;gt;forAll(e |  ctx.resolvedModelElements-&amp;gt;includes(e)) )&lt;/p>&lt;p>post :&lt;/p>&lt;p> self.boundaryElementBinding-&amp;gt;forAll(boundaryElt |boundaryElt.oclIsTypeOf(ToBinding) implies boundaryElt.oclAsType(ToBinding).toPlacement.insideBoundaryElement-&amp;gt;forAll(e | not ctx.resolvedModelElements-&amp;gt;includes(e)) )&lt;/p>&lt;p>           and self.boundaryElementBinding-&amp;gt;forAll(boundaryElt |boundaryElt.oclIsTypeOf(ToBinding) implies boundaryElt.oclAsType(ToBinding).toReplacement.insideBoundaryElement-&amp;gt;forAll(e |  ctx.resolvedModelElements-&amp;gt;includes(e)) )&lt;/p>&lt;p>Note : FragmentSubstitution needs the use of FromBinding and ToBinding metaclasses (please refer to the corresponding pre and post conditions).&lt;/p>&lt;p>####CVLSemanticEnd####&lt;/p>&lt;p>&lt;/p>"/>
      </eAnnotations>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="multi" ordered="false"
          lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EBoolean"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="substitutes" upperBound="-1"
          eType="#//cvl/ObjectSubstitution"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="StructuralOrganisationalPattern" eSuperTypes="#//cvl/ChoiceVariationPoint #//cvl/RepeatableVariationPoint">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="&lt;p>Fragment Substitution substitutes a placement fragment of the base model with one or more replacement fragments of the base model.&lt;/p>&lt;p>Constraints:&lt;/p>&lt;p>The boundary elements define all references going in and out of the placement fragment. The boundary elements fully define all references going in and out of the replacement fragment.&lt;/p>&lt;p>Semantics:&lt;/p>&lt;p>1. Delete the model elements defined by the PlacementFragment. The placement model elements can be found through FragmentSubstitution.placement's placementBoundaryElements that are of class ToPlacement (using the model element references called insideBoundaryElement) and the transitive closure of all references from these, where the traversal is cut off at any reference that has the same value as any of FragmentSubstitution.placement's PlacementBoundardyElement that are of class FromPlacement (using the model element references called outsideBoundaryElement).&lt;/p>&lt;p>&lt;br>2. For the replacement fragments, copy its content onto the hole made by the deletion of the placement fragment. The placement and replacement boundary elements must correspond. The content model elements can be found through FragmentSubstitution. replacement's ReplacementBoundaryElement that are of type ToReplacement (using the model element references called insideBoundaryElement) and all model elements found through the transitive closure of all references from this set of model elements, where the traversal is cut off at any reference that has the same value as any of FragmentSubstitution.replacement's ReplacementBoundaryElement that are of type FromReplacement (using the model element references called outsideBoundaryElement).&lt;/p>&lt;p>If multi is true, then a number of copies of the replacement fragment will be copied onto the placement. The resolution model will define how many.&lt;/p>&lt;p>Any substitutions addressing placements inside the given replacement fragment will be performed on the copy of the replacement fragment which is the last one generated.&lt;/p>&lt;p>3. Binding boundary elements. The placement and replacement boundary elements are connected by bindings. The bindings are given by the BoundaryElementBindings:&lt;br>1. FromBinding: fromReplacement.insideBoundaryElement.propertyName[] = fromPlacement.outsideBoundaryElement[]&lt;br>2. ToBinding: toPlacement.outsideBoundaryElement.propertyName[] = toReplacement.insideBoundaryElement[]. This definition in fact also covers attributes that have multiplicity. Such attributes may be seen as arrays or collections, and repeated reference assignments to such attributes during variability transformation will mean adding a new individual reference to the identifier collection.&lt;/p>&lt;p>####CVLSemanticStart####&lt;/p>&lt;p>&lt;/p>&lt;p>Dynamic semantics&lt;/p>&lt;p>Pre and post condition&lt;/p>&lt;p>Pre-condition : &lt;/p>&lt;p>Before the execution of a Fragment Substitution, the placement fragment must exist in the base model.&lt;/p>&lt;p>Post-condition: &lt;/p>&lt;p>After a FragmentSubstitution has been executed, the placement elements cannot be found in the resolved model whereas the replacement elements are in the resolved model.&lt;/p>&lt;p>OCL :&lt;/p>&lt;p>context FragmentSubstitution::eval(ctx : CVLExecutionContext)&lt;/p>&lt;p>pre : &lt;/p>&lt;p>self.boundaryElementBinding-&amp;gt;forAll(boundaryElt |boundaryElt.oclIsTypeOf(ToBinding) implies boundaryElt.oclAsType(ToBinding).toPlacement.insideBoundaryElement-&amp;gt;forAll(e |  ctx.resolvedModelElements-&amp;gt;includes(e)) )&lt;/p>&lt;p>post :&lt;/p>&lt;p> self.boundaryElementBinding-&amp;gt;forAll(boundaryElt |boundaryElt.oclIsTypeOf(ToBinding) implies boundaryElt.oclAsType(ToBinding).toPlacement.insideBoundaryElement-&amp;gt;forAll(e | not ctx.resolvedModelElements-&amp;gt;includes(e)) )&lt;/p>&lt;p>           and self.boundaryElementBinding-&amp;gt;forAll(boundaryElt |boundaryElt.oclIsTypeOf(ToBinding) implies boundaryElt.oclAsType(ToBinding).toReplacement.insideBoundaryElement-&amp;gt;forAll(e |  ctx.resolvedModelElements-&amp;gt;includes(e)) )&lt;/p>&lt;p>Note : FragmentSubstitution needs the use of FromBinding and ToBinding metaclasses (please refer to the corresponding pre and post conditions).&lt;/p>&lt;p>####CVLSemanticEnd####&lt;/p>&lt;p>&lt;/p>"/>
      </eAnnotations>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="multi" ordered="false"
          lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EBoolean"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="substitutes" upperBound="-1"
          eType="#//cvl/ObjectSubstitution"/>
    </eClassifiers>
  </eSubpackages>
</ecore:EPackage>
