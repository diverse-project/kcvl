// automatically generated by Xtext
grammar fr.inria.diverse.kcvl.KCVL with org.eclipse.xtext.common.Terminals

import "platform:/resource/OMG-CVL/CVLMetamodel.ecore#//cvl" 
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

VPackage returns VPackage:
	'VP' name=ID '{'
		(packageElement += VPackageable)*
	'}';

VPackageable returns VPackageable:
	VPackage | VSpec | VariationPoint | VSpecResolution/* | VSpecDerivation | Constraint | OVPType | VInterface | VConfiguration*/;

VSpecDerivation returns VSpecDerivation:
	VSpecDerivation_Impl | ChoiceDerivation | VariableDerivation | CVSpecDerivation;

VSpec returns VSpec:
	Choice | VClassifier | Variable | CVSpec;

VSpecResolution returns VSpecResolution:
	ChoiceResolutuion | VInstance | VariableValueAssignment | VConfiguration;

VariationPoint returns VariationPoint:
	FragmentSubstitution | PlacementFragment | ObjectSubstitution | SlotAssignment | ObjectExistence | LinkAssignment | ConfigurableUnit | CompositeVariationPoint_Impl | LinkExistence | OpaqueVariationPoint | SlotValueExistence | ParametricLinkAssignment | ParametricObjectSubstitution | ParametricSlotAssignmet | ConfigurableUnitUsage | PatternIntegration | PatternFusion | StructuralOrganisationalPattern;

BoundaryElementBinding returns BoundaryElementBinding:
	ToBinding | FromBinding;

PlacementBoundaryElement returns PlacementBoundaryElement:
	ToPlacement | FromPlacement;

ReplacementBoundaryElement returns ReplacementBoundaryElement:
	ToReplacement | FromReplacement;


ValueSpecification returns ValueSpecification:
	ObjectSpecification | ReplacementFragmentSpecification | PrimitiveValueSpecification;

Variabletype returns Variabletype:
	ReplacementFragmentType | PrimitveType | ObjectType;


Constraint returns Constraint:
	Constraint_Impl | OpaqueConstraint | OCLConstraint;


BaseModelHandle returns BaseModelHandle:
	ObjectHandle | LinkHandle;



OCLExpression returns OCLExpression:
	OCLExpression_Impl | VSpecRef | OperationCallExp | BooleanLiteralExp | StringLiteralExp | NumericLiteralExp_Impl | IntegerLiteralExp | UnlimitedLiteralExp | RealLiteralExp;

Choice returns Choice:
	'choice' name = ID  (groupMultiplicity = MultiplicityInterval)?
	('{'
		(defaultResolution ?= 'defaultResolution')?
		(isImpliedByParent ?= 'impliedByParent')?
		('resolutionTime' resolutionTime = STRING)?
		//('ownedVSpecDerivation' ownedVSpecDerivation=VSpecDerivation)?
		//('child' '{' child+=VSpec ( "," child+=VSpec)* '}' )?
		(child += VSpec (child += VSpec)*)?
	'}')?;

VSpecDerivation_Impl returns VSpecDerivation:
	'VSpecDerivation'
	name=STRING
	'{'
		'derivedVSpec' derivedVSpec=[VSpec|STRING]
	'}';

VClassifier returns VClassifier:
	'VClassifier'
	name=STRING
	'{'
		'resolutionTime' resolutionTime=STRING
		('groupMultiplicity' groupMultiplicity=MultiplicityInterval)?
		('ownedVSpecDerivation' ownedVSpecDerivation=VSpecDerivation)?
		('child' '{' child+=VSpec ( "," child+=VSpec)* '}' )?
		'instanceMultiplicity' instanceMultiplicity=MultiplicityInterval
	'}';

ChoiceResolutuion returns ChoiceResolutuion:
	'ChoiceResolution' name = ID '=' decision = BOOLEAN 'forSpec' resolvedVSpec = [VSpec | ID] 'forChoice' resolvedChoice = [Choice | ID]
	('{' child += VSpecResolution (child += VSpecResolution)* '}')?
	;

VInstance returns VInstance:
	'VInstance'
	name=STRING
	'{'
		'resolvedVSpec' resolvedVSpec=[VSpec|STRING]
		'type' type=[VClassifier|STRING]
		('child' '{' child+=VSpecResolution ( "," child+=VSpecResolution)* '}' )?
	'}';

FragmentSubstitution returns FragmentSubstitution:
	multi?='multi'
	'FragmentSubstitution'
	name=STRING
	'{'
		('mappingExpression' mappingExpression=STRING)?
		('expression' expression=STRING)?
		('bindingVspec' '(' bindingVspec+=[VSpec|STRING] ( "," bindingVspec+=[VSpec|STRING])* ')' )?
		('precedenceConstraint' '(' precedenceConstraint+=[VariationPoint|STRING] ( "," precedenceConstraint+=[VariationPoint|STRING])* ')' )?
		('bindingChoice' '(' bindingChoice+=[Choice|STRING] ( "," bindingChoice+=[Choice|STRING])* ')' )?
		'bindingClassifier' bindingClassifier=[VClassifier|STRING]
		'placement' placement=[PlacementFragment|STRING]
		('replacement' replacement=[ReplacementFragmentType|STRING])?
		('boundaryElementBinding' '{' boundaryElementBinding+=BoundaryElementBinding ( "," boundaryElementBinding+=BoundaryElementBinding)* '}' )?
	'}';

PlacementFragment returns PlacementFragment:
	{PlacementFragment}
	'PlacementFragment'
	name=STRING
	'{'
		('bindingVspec' '(' bindingVspec+=[VSpec|STRING] ( "," bindingVspec+=[VSpec|STRING])* ')' )?
		('precedenceConstraint' '(' precedenceConstraint+=[VariationPoint|STRING] ( "," precedenceConstraint+=[VariationPoint|STRING])* ')' )?
		('placementBoundaryElement' '{' placementBoundaryElement+=PlacementBoundaryElement ( "," placementBoundaryElement+=PlacementBoundaryElement)* '}' )?
	'}';

ReplacementFragmentType returns ReplacementFragmentType:
	{ReplacementFragmentType}
	'ReplacementFragmentType'
	name=STRING
	'{'
		('replacementBoundaryElement' '{' replacementBoundaryElement+=ReplacementBoundaryElement ( "," replacementBoundaryElement+=ReplacementBoundaryElement)* '}' )?
		('placementFragment' '{' placementFragment+=PlacementFragment ( "," placementFragment+=PlacementFragment)* '}' )?
	'}';

ObjectSubstitution returns ObjectSubstitution:
	'ObjectSubstitution'
	name=STRING
	'{'
		('mappingExpression' mappingExpression=STRING)?
		('expression' expression=STRING)?
		('bindingVspec' '(' bindingVspec+=[VSpec|STRING] ( "," bindingVspec+=[VSpec|STRING])* ')' )?
		('precedenceConstraint' '(' precedenceConstraint+=[VariationPoint|STRING] ( "," precedenceConstraint+=[VariationPoint|STRING])* ')' )?
		('bindingChoice' '(' bindingChoice+=[Choice|STRING] ( "," bindingChoice+=[Choice|STRING])* ')' )?
		'placementObject' placementObject=ObjectHandle
		'replacementObject' replacementObject=ObjectHandle
	'}';

Variable returns Variable:
	'Variable'
	name=STRING
	'{'
		'resolutionTime' resolutionTime=STRING
		('replacementFragmentTypesubsetstype' replacementFragmentTypesubsetstype=[ReplacementFragmentType|STRING])?
		'type' type=[Variabletype|STRING]
		('groupMultiplicity' groupMultiplicity=MultiplicityInterval)?
		('ownedVSpecDerivation' ownedVSpecDerivation=VSpecDerivation)?
		('child' '{' child+=VSpec ( "," child+=VSpec)* '}' )?
		('defaulValue' defaulValue=ValueSpecification)?
	'}';

VariableValueAssignment returns VariableValueAssignment:
	'VariableValueAssignment'
	name=STRING
	'{'
		'resolvedVSpec' resolvedVSpec=[VSpec|STRING]
		'resolvedVariable' resolvedVariable=[Variable|STRING]
		('child' '{' child+=VSpecResolution ( "," child+=VSpecResolution)* '}' )?
		'value' value=ValueSpecification
	'}';

PrimitveType returns PrimitveType:
	type = PrimitiveTypeEnum
	/*'PrimitveType'
	name=STRING
	'{'
		'type' type=PrimitiveTypeEnum
	'}'*/;

ObjectType returns ObjectType:
	'ObjectType'
	name=STRING
	'{'
		'metaClass' metaClass=STRING
	'}';

VInterface returns VInterface:
	{VInterface}
	'VInterface'
	name=STRING
	'{'
		('super' super=[VInterface|STRING])?
		('member' '{' member+=VSpec ( "," member+=VSpec)* '}' )?
		('ownedConstraint' '{' ownedConstraint+=Constraint ( "," ownedConstraint+=Constraint)* '}' )?
	'}';

Constraint_Impl returns Constraint:
	{Constraint}
	'Constraint'
	name=STRING
	'{'
		('context' context=[VSpec|STRING])?
	'}';

SlotAssignment returns SlotAssignment:
	'SlotAssignment'
	name=STRING
	'{'
		('mappingExpression' mappingExpression=STRING)?
		('expression' expression=STRING)?
		'slotIdentifier' slotIdentifier=STRING
		('bindingVspec' '(' bindingVspec+=[VSpec|STRING] ( "," bindingVspec+=[VSpec|STRING])* ')' )?
		('precedenceConstraint' '(' precedenceConstraint+=[VariationPoint|STRING] ( "," precedenceConstraint+=[VariationPoint|STRING])* ')' )?
		('bindingChoice' '(' bindingChoice+=[Choice|STRING] ( "," bindingChoice+=[Choice|STRING])* ')' )?
		('value' value=ValueSpecification)?
		'SlotOwner' SlotOwner=ObjectHandle
	'}';

ObjectExistence returns ObjectExistence:
	'ObjectExistence' name = ID	'{'
		('mappingExpression' mappingExpression=STRING)?
		('expression' expression=STRING)?
		('bindingVspec' '(' bindingVspec+=[VSpec|STRING] ( "," bindingVspec+=[VSpec|STRING])* ')' )?
		('precedenceConstraint' '(' precedenceConstraint+=[VariationPoint|STRING] ( "," precedenceConstraint+=[VariationPoint|STRING])* ')' )?
		//('bindingChoice' '(' bindingChoice+=[Choice|STRING] ( "," bindingChoice+=[Choice|STRING])* ')' )?
		('exist' optionalObject += (ObjectHandle | SimpleObjectHandle))*
		('choice' bindingChoice += [Choice|ID] ("," bindingChoice+=[Choice|ID])*)?
	'}';

LinkAssignment returns LinkAssignment:
	'LinkAssignment' name = ID '{'
		('mappingExpression' mappingExpression=STRING)?
		('expression' expression=STRING)?
		('bindingVspec' '(' bindingVspec+=[VSpec|STRING] ( "," bindingVspec+=[VSpec|STRING])* ')' )?
		('precedenceConstraint' '(' precedenceConstraint+=[VariationPoint|STRING] ( "," precedenceConstraint+=[VariationPoint|STRING])* ')' )?
		'link' link = (LinkHandle | SimpleLinkHandle)
		'linkEndIdentifier' linkEndIdentifier = STRING
		'newEnd' newEnd = (ObjectHandle | SimpleObjectHandle)
		('choice' bindingChoice += [Choice|ID] ("," bindingChoice+=[Choice|ID])*)?
	'}';

ConfigurableUnit returns ConfigurableUnit:
	'ConfigurableUnit'
	name=STRING
	'{'
		('bindingVspec' '(' bindingVspec+=[VSpec|STRING] ( "," bindingVspec+=[VSpec|STRING])* ')' )?
		('precedenceConstraint' '(' precedenceConstraint+=[VariationPoint|STRING] ( "," precedenceConstraint+=[VariationPoint|STRING])* ')' )?
		'bindingCVSpec' bindingCVSpec=[CVSpec|STRING]
		'unitInterface' unitInterface=[VInterface|STRING]
		('children' '{' children+=VariationPoint ( "," children+=VariationPoint)* '}' )?
		('ownedVSpec' '{' ownedVSpec+=VSpec ( "," ownedVSpec+=VSpec)* '}' )?
		('ownedVariationPoint' '{' ownedVariationPoint+=VariationPoint ( "," ownedVariationPoint+=VariationPoint)* '}' )?
		('ownedConstraint' '{' ownedConstraint+=Constraint ( "," ownedConstraint+=Constraint)* '}' )?
		'configurableContainerObject' configurableContainerObject=ObjectHandle
		('ownedVSpecResolution' '{' ownedVSpecResolution+=VSpecResolution ( "," ownedVSpecResolution+=VSpecResolution)* '}' )?
	'}';

CompositeVariationPoint_Impl returns CompositeVariationPoint:
	'CompositeVariationPoint'
	name=STRING
	'{'
		('bindingVspec' '(' bindingVspec+=[VSpec|STRING] ( "," bindingVspec+=[VSpec|STRING])* ')' )?
		('precedenceConstraint' '(' precedenceConstraint+=[VariationPoint|STRING] ( "," precedenceConstraint+=[VariationPoint|STRING])* ')' )?
		'bindingCVSpec' bindingCVSpec=[CVSpec|STRING]
		('children' '{' children+=VariationPoint ( "," children+=VariationPoint)* '}' )?
	'}';

CVSpec returns CVSpec:
	'CVSpec'
	name=STRING
	'{'
		'resolutionTime' resolutionTime=STRING
		'extension' extension=[VInterface|STRING]
		('groupMultiplicity' groupMultiplicity=MultiplicityInterval)?
		('ownedVSpecDerivation' ownedVSpecDerivation=VSpecDerivation)?
		('child' '{' child+=VSpec ( "," child+=VSpec)* '}' )?
	'}';

VConfiguration returns VConfiguration:
	isPartial?='isPartial'
	'VConfiguration'
	name=STRING
	'{'
		'resolvedVSpec' resolvedVSpec=[VSpec|STRING]
		('super' super=[VConfiguration|STRING])?
		'resolvedVIRef' resolvedVIRef=[CVSpec|STRING]
		('child' '{' child+=VSpecResolution ( "," child+=VSpecResolution)* '}' )?
		('member' '{' member+=VSpecResolution ( "," member+=VSpecResolution)* '}' )?
	'}';

OpaqueConstraint returns OpaqueConstraint:
	'OpaqueConstraint'
	name=STRING
	'{'
		'constraint' constraint=STRING
		'constraintLanguage' constraintLanguage=STRING
		('context' context=[VSpec|STRING])?
	'}';

LinkExistence returns LinkExistence:
	'LinkExistence'	name = ID '{'
		('mappingExpression' mappingExpression=STRING)?
		('expression' expression=STRING)?
		('bindingVspec' '(' bindingVspec+=[VSpec|STRING] ( "," bindingVspec+=[VSpec|STRING])* ')' )?
		('precedenceConstraint' '(' precedenceConstraint+=[VariationPoint|STRING] ( "," precedenceConstraint+=[VariationPoint|STRING])* ')' )?
		'link' optionalLink = (LinkHandle | SimpleLinkHandle)
		('choice' bindingChoice += [Choice | ID] ("," bindingChoice+=[Choice | ID])*)?
	'}';

OpaqueVariationPoint returns OpaqueVariationPoint:
	'OpaqueVariationPoint'
	name=STRING
	'{'
		('mappingExpression' mappingExpression=STRING)?
		('expression' expression=STRING)?
		('bindingVspec' '(' bindingVspec+=[VSpec|STRING] ( "," bindingVspec+=[VSpec|STRING])* ')' )?
		('precedenceConstraint' '(' precedenceConstraint+=[VariationPoint|STRING] ( "," precedenceConstraint+=[VariationPoint|STRING])* ')' )?
		('bindingChoice' '(' bindingChoice+=[Choice|STRING] ( "," bindingChoice+=[Choice|STRING])* ')' )?
		'type' type=[OVPType|STRING]
		//'placeHolder' placeHolder=BaseModelHandle
		'sourceObject' '{' sourceObject+=ObjectHandle ( "," sourceObject+=ObjectHandle)* '}' 
	'}';

OVPType returns OVPType:
	'OVPType'
	name=STRING
	'{'
		'spec' spec=OVPSemanticSpec
	'}';

SlotValueExistence returns SlotValueExistence:
	'SlotValueExistence'
	name=STRING
	'{'
		('mappingExpression' mappingExpression=STRING)?
		('expression' expression=STRING)?
		'slotIdentifier' slotIdentifier=STRING
		('bindingVspec' '(' bindingVspec+=[VSpec|STRING] ( "," bindingVspec+=[VSpec|STRING])* ')' )?
		('precedenceConstraint' '(' precedenceConstraint+=[VariationPoint|STRING] ( "," precedenceConstraint+=[VariationPoint|STRING])* ')' )?
		('bindingChoice' '(' bindingChoice+=[Choice|STRING] ( "," bindingChoice+=[Choice|STRING])* ')' )?
		'slotOwner' slotOwner=ObjectHandle
	'}';

ParametricLinkAssignment returns ParametricLinkAssignment:
	'ParametricLinkAssignment'
	name=STRING
	'{'
		'linkEndIdentifier' linkEndIdentifier=STRING
		('bindingVspec' '(' bindingVspec+=[VSpec|STRING] ( "," bindingVspec+=[VSpec|STRING])* ')' )?
		('precedenceConstraint' '(' precedenceConstraint+=[VariationPoint|STRING] ( "," precedenceConstraint+=[VariationPoint|STRING])* ')' )?
		'bindingVariable' bindingVariable=[Variable|STRING]
		'link' link=LinkHandle
	'}';

ParametricObjectSubstitution returns ParametricObjectSubstitution:
	'ParametricObjectSubstitution'
	name=STRING
	'{'
		('bindingVspec' '(' bindingVspec+=[VSpec|STRING] ( "," bindingVspec+=[VSpec|STRING])* ')' )?
		('precedenceConstraint' '(' precedenceConstraint+=[VariationPoint|STRING] ( "," precedenceConstraint+=[VariationPoint|STRING])* ')' )?
		'bindingVariable' bindingVariable=[Variable|STRING]
		'placementObject' placementObject=ObjectHandle
	'}';

ParametricSlotAssignmet returns ParametricSlotAssignmet:
	'ParametricSlotAssignmet'
	name=STRING
	'{'
		'slotIdentifier' slotIdentifier=STRING
		('bindingVspec' '(' bindingVspec+=[VSpec|STRING] ( "," bindingVspec+=[VSpec|STRING])* ')' )?
		('precedenceConstraint' '(' precedenceConstraint+=[VariationPoint|STRING] ( "," precedenceConstraint+=[VariationPoint|STRING])* ')' )?
		'bindingVariable' bindingVariable=[Variable|STRING]
		'slotOwner' slotOwner=ObjectHandle
	'}';

ChoiceDerivation returns ChoiceDerivation:
	'ChoiceDerivation'
	name=STRING
	'{'
		'derivedVSpec' derivedVSpec=[VSpec|STRING]
		'derivingConstraint' derivingConstraint=Constraint
	'}';

VariableDerivation returns VariableDerivation:
	'VariableDerivation'
	name=STRING
	'{'
		'derivedVSpec' derivedVSpec=[VSpec|STRING]
		'derivingExpression' derivingExpression=OCLExpression
	'}';

CVSpecDerivation returns CVSpecDerivation:
	'CVSpecDerivation'
	name=STRING
	'{'
		'derivedVSpec' derivedVSpec=[VSpec|STRING]
		('memberDerivation' '{' memberDerivation+=VSpecDerivation ( "," memberDerivation+=VSpecDerivation)* '}' )?
	'}';

ConfigurableUnitUsage returns ConfigurableUnitUsage:
	'ConfigurableUnitUsage'
	name=STRING
	'{'
		'linkEndIdentifier' linkEndIdentifier=STRING
		('bindingVspec' '(' bindingVspec+=[VSpec|STRING] ( "," bindingVspec+=[VSpec|STRING])* ')' )?
		('precedenceConstraint' '(' precedenceConstraint+=[VariationPoint|STRING] ( "," precedenceConstraint+=[VariationPoint|STRING])* ')' )?
		'bindingCVSpec' bindingCVSpec=[CVSpec|STRING]
		'usedUnit' usedUnit=[ConfigurableUnit|STRING]
		('children' '{' children+=VariationPoint ( "," children+=VariationPoint)* '}' )?
		'usageReference' usageReference=LinkHandle
	'}';

OCLConstraint returns OCLConstraint:
	'OCLConstraint'
	name=STRING
	'{'
		('context' context=[VSpec|STRING])?
		'expression' '{' expression+=OCLExpression ( "," expression+=OCLExpression)* '}' 
	'}';

PatternIntegration returns PatternIntegration:
	multi?='multi'
	'PatternIntegration'
	name=STRING
	'{'
		('mappingExpression' mappingExpression=STRING)?
		('expression' expression=STRING)?
		('bindingVspec' '(' bindingVspec+=[VSpec|STRING] ( "," bindingVspec+=[VSpec|STRING])* ')' )?
		('precedenceConstraint' '(' precedenceConstraint+=[VariationPoint|STRING] ( "," precedenceConstraint+=[VariationPoint|STRING])* ')' )?
		('bindingChoice' '(' bindingChoice+=[Choice|STRING] ( "," bindingChoice+=[Choice|STRING])* ')' )?
		'bindingClassifier' bindingClassifier=[VClassifier|STRING]
		('substitutes' '(' substitutes+=[ObjectSubstitution|STRING] ( "," substitutes+=[ObjectSubstitution|STRING])* ')' )?
	'}';

PatternFusion returns PatternFusion:
	multi?='multi'
	'PatternFusion'
	name=STRING
	'{'
		('mappingExpression' mappingExpression=STRING)?
		('expression' expression=STRING)?
		('bindingVspec' '(' bindingVspec+=[VSpec|STRING] ( "," bindingVspec+=[VSpec|STRING])* ')' )?
		('precedenceConstraint' '(' precedenceConstraint+=[VariationPoint|STRING] ( "," precedenceConstraint+=[VariationPoint|STRING])* ')' )?
		('bindingChoice' '(' bindingChoice+=[Choice|STRING] ( "," bindingChoice+=[Choice|STRING])* ')' )?
		'bindingClassifier' bindingClassifier=[VClassifier|STRING]
		('substitutes' '(' substitutes+=[ObjectSubstitution|STRING] ( "," substitutes+=[ObjectSubstitution|STRING])* ')' )?
	'}';

StructuralOrganisationalPattern returns StructuralOrganisationalPattern:
	multi?='multi'
	'StructuralOrganisationalPattern'
	name=STRING
	'{'
		('mappingExpression' mappingExpression=STRING)?
		('expression' expression=STRING)?
		('bindingVspec' '(' bindingVspec+=[VSpec|STRING] ( "," bindingVspec+=[VSpec|STRING])* ')' )?
		('precedenceConstraint' '(' precedenceConstraint+=[VariationPoint|STRING] ( "," precedenceConstraint+=[VariationPoint|STRING])* ')' )?
		('bindingChoice' '(' bindingChoice+=[Choice|STRING] ( "," bindingChoice+=[Choice|STRING])* ')' )?
		'bindingClassifier' bindingClassifier=[VClassifier|STRING]
		('substitutes' '(' substitutes+=[ObjectSubstitution|STRING] ( "," substitutes+=[ObjectSubstitution|STRING])* ')' )?
	'}';

MultiplicityInterval returns MultiplicityInterval:
	'[' lower = INT '..' upper = INT ']'
;

BOOLEAN returns ecore::EBoolean:
	'true' | 'false';

ToBinding returns ToBinding:
	'ToBinding'
	'{'
		'toPlacement' toPlacement=[ToPlacement|STRING]
		'toReplacement' toReplacement=[ToReplacement|STRING]
	'}';

FromBinding returns FromBinding:
	'FromBinding'
	'{'
		'fromPlacement' fromPlacement=[FromPlacement|STRING]
		'fromReplacement' fromReplacement=[FromReplacement|STRING]
	'}';

ToPlacement returns ToPlacement:
	'ToPlacement'
	'{'
		'propertyName' propertyName=STRING
		('insideBoundaryElement' '{' insideBoundaryElement+=ObjectHandle ( "," insideBoundaryElement+=ObjectHandle)* '}' )?
		('outsideBoundaryElement' outsideBoundaryElement=ObjectHandle)?
	'}';

ToReplacement returns ToReplacement:
	{ToReplacement}
	'ToReplacement'
	'{'
		('insideBoundaryElement' '{' insideBoundaryElement+=ObjectHandle ( "," insideBoundaryElement+=ObjectHandle)* '}' )?
		('toPlacement' toPlacement=ToPlacement)?
	'}';

SimpleObjectHandle returns ObjectHandle:
	referenceString = STRING
;

ObjectHandle returns ObjectHandle:
	'(' 'mofRef' ':' MOFRef = STRING ',' 'reference' ':' referenceString = STRING ')'
;

FromPlacement returns FromPlacement:
	{FromPlacement}
	'FromPlacement'
	'{'
		('fromReplacement' fromReplacement=[FromReplacement|STRING])?
		('outsideBoundaryElement' '{' outsideBoundaryElement+=ObjectHandle ( "," outsideBoundaryElement+=ObjectHandle)* '}' )?
	'}';

FromReplacement returns FromReplacement:
	'FromReplacement'
	'{'
		'propertyName' propertyName=STRING
		('fromPlacement' fromPlacement=[FromPlacement|STRING])?
		('insideBoundaryElement' insideBoundaryElement=ObjectHandle)?
		('outsideBoundaryElement' '{' outsideBoundaryElement+=ObjectHandle ( "," outsideBoundaryElement+=ObjectHandle)* '}' )?
	'}';

ObjectSpecification returns ObjectSpecification:
	'ObjectSpecification'
	'{'
		'type' type=[Variabletype|STRING]
		'object' object=[ObjectHandle|STRING]
	'}';

ReplacementFragmentSpecification returns ReplacementFragmentSpecification:
	'ReplacementFragmentSpecification'
	'{'
		'type' type=[Variabletype|STRING]
	'}';

PrimitiveValueSpecification returns PrimitiveValueSpecification:
	'PrimitiveValueSpecification'
	'{'
		('value' value=STRING)?
		'type' type=[Variabletype|STRING]
		'expression' expression=OCLExpression
	'}';

OCLExpression_Impl returns OCLExpression:
	{OCLExpression}
	'OCLExpression'
	;

VSpecRef returns VSpecRef:
	'VSpecRef'
	'{'
		'vSpec' vSpec=[VSpec|STRING]
	'}';

OperationCallExp returns OperationCallExp:
	'OperationCallExp'
	'{'
		'operation' operation=Operation
		('argument' '{' argument+=OCLExpression ( "," argument+=OCLExpression)* '}' )?
	'}';

BooleanLiteralExp returns BooleanLiteralExp:
	bool?='bool'
	'BooleanLiteralExp'
	;

StringLiteralExp returns StringLiteralExp:
	'StringLiteralExp'
	'{'
		'string' string=STRING
	'}';

NumericLiteralExp_Impl returns NumericLiteralExp:
	{NumericLiteralExp}
	'NumericLiteralExp'
	;

IntegerLiteralExp returns IntegerLiteralExp:
	'IntegerLiteralExp'
	'{'
		'integer' integer=INT
	'}';

UnlimitedLiteralExp returns UnlimitedLiteralExp:
	'UnlimitedLiteralExp'
	'{'
		'unlimited' unlimited=INT
	'}';

RealLiteralExp returns RealLiteralExp:
	'RealLiteralExp'
	'{'
		'real' real=EDouble
	'}';

enum Operation returns Operation:
				logNot = 'logNot' | logAnd = 'logAnd' | logOr = 'logOr' | logImplies = 'logImplies' | logXor = 'logXor' | logIff = 'logIff' | arithPlus = 'arithPlus' | arithMinus = 'arithMinus' | arithNeg = 'arithNeg' | arithMult = 'arithMult' | arithDev = 'arithDev' | strConc = 'strConc' | eq = 'eq' | lte = 'lte' | gte = 'gte' | lt = 'lt' | gt = 'gt' | isDefined = 'isDefined' | isUndefined = 'isUndefined';

EDouble returns ecore::EDouble:
	'-'? INT? '.' INT (('E'|'e') '-'? INT)?;

enum PrimitiveTypeEnum returns PrimitiveTypeEnum:
				String = 'String' | Boolean = 'Boolean' | Integer = 'Integer' | Real = 'Real' | UnlimitedNatural = 'UnlimitedNatural';

SimpleLinkHandle returns LinkHandle:
	referenceString = STRING
;

LinkHandle returns LinkHandle:
	'(' 'mofRef' ':' MOFRef = STRING ',' 'reference' ':' referenceString = STRING ')'
;

BaseModelHandle_Impl returns BaseModelHandle:
	{BaseModelHandle}
	'BaseModelHandle'
	'{'
		('reference' reference=[ecore::EObject|STRING])?
	'}';

OVPSemanticSpec returns OVPSemanticSpec:
	'OVPSemanticSpec'
	'{'
		'modelTransformation' modelTransformation=STRING
		'transfromationLanguage' transfromationLanguage=STRING
	'}';
